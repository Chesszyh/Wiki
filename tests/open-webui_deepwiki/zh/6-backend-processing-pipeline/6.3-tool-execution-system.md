# 工具执行系统

相关源文件

-   [backend/open\_webui/config.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/config.py)
-   [backend/open\_webui/main.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py)
-   [backend/open\_webui/retrieval/loaders/datalab\_marker.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/datalab_marker.py)
-   [backend/open\_webui/retrieval/loaders/external\_document.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/external_document.py)
-   [backend/open\_webui/retrieval/loaders/external\_web.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/external_web.py)
-   [backend/open\_webui/retrieval/loaders/main.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/main.py)
-   [backend/open\_webui/retrieval/loaders/mineru.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/mineru.py)
-   [backend/open\_webui/retrieval/loaders/mistral.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/mistral.py)
-   [backend/open\_webui/retrieval/utils.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py)
-   [backend/open\_webui/routers/retrieval.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/routers/retrieval.py)
-   [backend/open\_webui/utils/middleware.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py)
-   [src/lib/apis/retrieval/index.ts](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/apis/retrieval/index.ts)
-   [src/lib/components/admin/Settings/Documents.svelte](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/components/admin/Settings/Documents.svelte)
-   [src/lib/components/admin/Settings/WebSearch.svelte](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/components/admin/Settings/WebSearch.svelte)

## 目的与范围

工具执行系统使 AI 模型能够在聊天补全过程中调用外部函数、执行代码并与外部服务交互。该系统提供了三条主要的执行路径：**基于函数的工具**（在“工具/函数”中定义的 Python 代码）、**OpenAPI 工具**（外部 HTTP API）以及 **MCP 服务器**（模型上下文协议服务器）。该系统负责处理工具调用、结果处理以及将工具输出集成回对话上下文中。

有关编排工具调用的中间件流水线的信息，请参阅 [请求处理流程](/open-webui/open-webui/4.1-chat-component-architecture)。有关与工具独立运行的基于 RAG 的文档检索，请参阅 [RAG 与知识库系统](/open-webui/open-webui/5-message-rendering)。

## 工具类型与架构

### 工具类别

Open WebUI 支持三种不同的工具执行机制：

| 工具类型 | 描述 | 存储位置 | 执行上下文 |
| --- | --- | --- | --- |
| **函数 (Functions)** | 通过自定义 `Tools` 类在服务器端执行的 Python 代码 | `app.state.FUNCTIONS` | 后端 FastAPI 进程 |
| **OpenAPI 工具** | 通过 OpenAPI 规范定义的外部 HTTP API | `app.state.TOOLS` | 外部 HTTP 端点 |
| **MCP 服务器** | 提供资源和工具的模型上下文协议 (Model Context Protocol) 服务器 | `TOOL_SERVER_CONNECTIONS` 配置 | 外部 MCP 进程 |

来源： [backend/open\_webui/main.py813-817](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L813-L817) [backend/open\_webui/utils/middleware.py285-516](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L285-L516)

### 工具状态管理

```mermaid
flowchart TD
    TOOLS["app.state.TOOLS (字典)"]
    TOOL_CONTENTS["app.state.TOOL_CONTENTS (字典)"]
    FUNCTIONS["app.state.FUNCTIONS (字典)"]
    FUNCTION_CONTENTS["app.state.FUNCTION_CONTENTS (字典)"]
    TOOL_SERVERS["app.state.TOOL_SERVERS (列表)"]
    TOOL_SERVER_CONNECTIONS["TOOL_SERVER_CONNECTIONS 配置"]
    get_tools["get_tools()"]
    tool_spec["工具规范 {name, spec, callable, type}"]
    chat_completion_tools_handler["chat_completion_tools_handler()"]
    tool_call_handler["tool_call_handler()"]
    event_caller["event_caller() (execute:tool)"]

    TOOL_SERVER_CONNECTIONS --> TOOL_SERVERS
    TOOLS --> get_tools
    FUNCTIONS --> get_tools
    TOOL_SERVERS --> get_tools
    get_tools --> tool_spec
    tool_spec --> chat_completion_tools_handler
    chat_completion_tools_handler --> tool_call_handler
    tool_call_handler --> event_caller
```
**图表：工具状态架构与注册表**

系统在应用程序状态中为工具和函数维护独立的字典。在运行时，`get_tools()` 将这些内容合并为一个统一的工具注册表，其规范与 OpenAI 函数调用兼容。

来源： [backend/open\_webui/main.py813-817](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L813-L817) [backend/open\_webui/utils/middleware.py285-516](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L285-L516) [backend/open\_webui/utils/tools.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/tools.py)

## 工具调用流程

### 函数调用生成

工具执行系统采用两阶段方法：首先通过任务模型生成工具调用，然后执行选定的工具。

> **[Mermaid sequence]**
> *(图表结构无法解析)*

**图表：工具调用序列**

系统使用 `TOOLS_FUNCTION_CALLING_PROMPT_TEMPLATE` 指示任务模型生成工具调用。模板包含工具规范和聊天历史，生成包含工具名称和参数的结构化 JSON。

来源： [backend/open\_webui/utils/middleware.py285-360](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L285-L360) [backend/open\_webui/utils/middleware.py368-502](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L368-L502)

### 工具调用处理器实现

核心工具调用逻辑位于 `chat_completion_tools_handler` 内部的 `tool_call_handler` 异步函数中：

```mermaid
flowchart TD
    tool_call["tool_call {name, parameters}"]
    validate_tool["工具函数名 是否在注册表中？"]
    return_empty["返回 body, {}"]
    get_tool["从注册表获取工具"]
    filter_params["按 spec.properties 过滤参数"]
    check_direct["tool.direct == true?"]
    event_caller["await event_caller() {type: 'execute:tool', data: {id, name, params, server}}"]
    callable["await tool_function()(**tool_function_params)"]
    process_result["process_tool_result()"]
    extract_files["提取工具结果文件 (图像, data URL)"]
    extract_embeds["提取工具结果嵌入 (HTML, iframe)"]
    emit_files["是否存在工具结果文件？"]
    emit_files_event["await event_emitter() {type: 'files'}"]
    emit_embeds["是否存在工具结果嵌入？"]
    emit_embeds_event["await event_emitter() {type: 'embeds'}"]
    add_source["添加到 sources[] {source, document, metadata}"]
    update_messages["add_or_update_user_message() 将工具输出加入消息"]
    check_file_handler["tool.metadata.file_handler?"]
    skip_files["设置 skip_files = True"]
    done["完成"]

    tool_call --> validate_tool
    validate_tool -- 否 --> return_empty
    validate_tool -- 是 --> get_tool
    get_tool --> filter_params
    filter_params --> check_direct
    check_direct -- 是 --> event_caller
    check_direct -- 否 --> callable
    event_caller --> process_result
    callable --> process_result
    process_result --> extract_files
    extract_files --> extract_embeds
    extract_files --> emit_files
    emit_files -- 是 --> emit_files_event
    emit_files -- 否 --> emit_embeds
    emit_files_event --> emit_embeds
    emit_embeds -- 是 --> emit_embeds_event
    emit_embeds -- 否 --> add_source
    emit_embeds_event --> add_source
    add_source --> update_messages
    update_messages --> check_file_handler
    check_file_handler -- 是 --> skip_files
    check_file_handler -- 否 --> done
    skip_files --> done
```
**图表：工具调用处理器控制流**

该处理器验证工具是否存在，对照工具规范过滤参数，调用直接工具（通过事件系统）或可调用函数，处理结果，并将输出注入到对话上下文中。

来源： [backend/open\_webui/utils/middleware.py368-495](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L368-L495)

## 工具结果处理

### 结果类型处理

`process_tool_result` 函数处理来自工具的多种输出格式：

```mermaid
flowchart TD
    tool_result["tool_result (原始输出)"]
    check_html["是否为 HTMLResponse 实例？"]
    check_disposition["Content-Disposition == 'inline'?"]
    extract_html["提取 HTML 正文 并添加到 tool_result_embeds"]
    decode_body["将正文解码为字符串"]
    check_tuple["tool_type == 'external' 且为元组？"]
    unpack["解包 (result, headers)"]
    check_inline["headers Content-Disposition == 'inline'?"]
    check_content_type["检查 Content-Type?"]
    add_iframe["添加到 tool_result_embeds (iframe 内容)"]
    add_location["将位置添加到 embeds"]
    check_list["是否为列表实例？"]
    check_mcp["tool_type == 'mcp'?"]
    process_mcp["处理 MCP 项 {type: text/image/audio}"]
    extract_mcp_files["提取图像/音频 为 tool_result_files"]
    process_openapi["处理 OpenAPI 项 提取 data: URL"]
    extract_openapi_files["添加到 tool_result_files"]
    jsonify["是否为字典或列表？"]
    json_dumps["json.dumps() indent=2"]
    to_string["转换为字符串"]
    return_tuple["返回 (tool_result, tool_result_files, tool_result_embeds)"]

    tool_result --> check_html
    check_html -- 是 --> check_disposition
    check_disposition -- 是 --> extract_html
    check_disposition -- 否 --> decode_body
    check_html -- 否 --> check_tuple
    check_tuple -- 是 --> unpack
    unpack --> check_inline
    check_inline -- 是 --> check_content_type
    check_content_type --> add_iframe
    check_content_type --> add_location
    check_tuple -- 否 --> check_list
    check_list -- 是 --> check_mcp
    check_mcp -- 是 --> process_mcp
    process_mcp --> extract_mcp_files
    check_mcp -- 否 --> process_openapi
    process_openapi --> extract_openapi_files
    check_list -- 否 --> jsonify
    jsonify -- 是 --> json_dumps
    jsonify -- 否 --> to_string
    extract_html --> return_tuple
    decode_body --> return_tuple
    add_iframe --> return_tuple
    add_location --> return_tuple
    extract_mcp_files --> return_tuple
    extract_openapi_files --> return_tuple
    json_dumps --> return_tuple
    to_string --> return_tuple
```
**图表：工具结果处理流水线**

该函数处理 HTMLResponse 对象、带请求头的元组（针对外部工具）、MCP 格式的响应，并将复杂对象转换为 JSON 字符串以便注入对话。

来源： [backend/open\_webui/utils/middleware.py142-282](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L142-L282)

### 结果集成

工具结果通过四种机制集成到聊天流中：

| 集成类型 | 用途 | 事件类型 | 存储 |
| --- | --- | --- | --- |
| **文件 (Files)** | 图像、音频、data URL | `{type: 'files', data: {files: []}}` | 在聊天中内联显示 |
| **嵌入 (Embeds)** | HTML/iframe 内容 | `{type: 'embeds', data: {embeds: []}}` | 渲染为嵌入式 UI |
| **来源 (Sources)** | 引用上下文 | 添加到 `sources[]` 数组 | 用于 RAG 风格的引用 |
| **用户消息** | 文本输出 | 通过 `add_or_update_user_message()` 追加 | 注入消息上下文 |

当工具在其元数据中声明 `file_handler = True` 时，将设置 `skip_files` 标志，防止对自行管理文件的工具进行默认文件处理。

来源： [backend/open\_webui/utils/middleware.py430-495](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L430-L495)

## 代码执行引擎

### 客户端：Pyodide Worker

基于浏览器的 Python 执行使用运行 Pyodide 的 Web Worker：

```mermaid
flowchart TD
    CodeBlock["CodeBlock.svelte executePython()"]
    PyodideWorker_Instance["PyodideWorker (Web Worker)"]
    worker_onmessage["worker.onmessage"]
    loadPyodideAndPackages["loadPyodideAndPackages()"]
    loadPyodide_fn["loadPyodide() indexURL: /pyodide/"]
    micropip["micropip.install()(packages)"]
    pyodide_run["pyodide.runPythonAsync()"]
    stdout_capture["stdout 回调 self.stdout += text"]
    stderr_capture["stderr 回调 self.stderr += text"]
    detect_packages["检测 import (requests, numpy, pandas 等)"]
    create_worker["new PyodideWorker()"]
    post_message["postMessage {id, code, packages}"]
    matplotlib_override["code 是否包含 'matplotlib'?"]
    override_show["覆盖 plt.show() 转换为 base64"]
    process_result["processResult() 递归序列化"]
    post_response["postMessage {id, result, stdout, stderr}"]
    onmessage["pyodideWorker.onmessage"]
    extract_output["提取 stdout, stderr, result"]
    extract_images["提取 data:image/png URL"]
    display["在 CodeBlock 中显示"]

    CodeBlock --> detect_packages
    detect_packages --> create_worker
    create_worker --> post_message
    post_message --> worker_onmessage
    worker_onmessage --> loadPyodideAndPackages
    loadPyodideAndPackages --> loadPyodide_fn
    loadPyodide_fn --> stdout_capture
    loadPyodide_fn --> stderr_capture
    loadPyodide_fn --> micropip
    micropip --> matplotlib_override
    matplotlib_override -- 是 --> override_show
    matplotlib_override -- 否 --> pyodide_run
    override_show --> pyodide_run
    pyodide_run --> process_result
    process_result --> post_response
    post_response --> PyodideWorker_Instance
    PyodideWorker_Instance --> onmessage
    onmessage --> extract_output
    extract_output --> extract_images
    extract_images --> display
```
**图表：Pyodide Worker 执行流程**

Worker 加载 Pyodide 以及从 import 语句中检测到的可配置包集。对于 matplotlib 绘图，系统会覆盖 `plt.show()` 以捕获 base64 编码的 PNG 图像，而不是尝试在 Worker 上下文中显示。

来源： [src/lib/workers/pyodide.worker.ts1-167](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/workers/pyodide.worker.ts#L1-L167) [src/lib/components/chat/Messages/CodeBlock.svelte139-329](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/components/chat/Messages/CodeBlock.svelte#L139-L329)

### 服务器端：Jupyter 内核

对于服务器端执行，系统可以使用 Jupyter 内核：

```mermaid
flowchart TD
    CodeBlock_Jupyter["CodeBlock.svelte $config.code.engine === 'jupyter'"]
    executeCode_endpoint["/api/utils/code POST"]
    execute_code_jupyter["execute_code_jupyter()"]
    KernelManager["Jupyter 内核管理器"]
    Kernel["Python 内核"]
    executeCode_api["executeCode(token, code)"]
    auth_check["是否配置了身份验证？"]
    basic_auth["HTTPBasicAuth"]
    bearer_auth["Authorization: token"]
    no_auth["无身份验证"]
    create_session["POST /api/sessions"]
    execute_request["POST /api/kernels/{id}/execute"]
    wait_completion["轮询直到状态 != 'busy'"]
    collect_outputs["收集输出 {stdout, result, stderr}"]
    cleanup["DELETE /api/kernels/{id}"]
    return_response["返回 {stdout, result, stderr}"]

    CodeBlock_Jupyter --> executeCode_api
    executeCode_api --> executeCode_endpoint
    executeCode_endpoint --> execute_code_jupyter
    execute_code_jupyter --> auth_check
    auth_check -- Basic --> basic_auth
    auth_check -- Bearer --> bearer_auth
    auth_check -- None --> no_auth
    basic_auth --> create_session
    bearer_auth --> create_session
    no_auth --> create_session
    create_session --> KernelManager
    KernelManager --> Kernel
    Kernel --> execute_request
    execute_request --> wait_completion
    wait_completion --> collect_outputs
    collect_outputs --> cleanup
    cleanup --> return_response
    return_response --> CodeBlock_Jupyter
```
**图表：Jupyter 内核执行流程**

Jupyter 执行路径创建一个临时的内核会话、执行代码、轮询完成状态、收集输出（包括显示数据）并清理内核。

来源： [backend/open\_webui/utils/code\_interpreter.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/code_interpreter.py) [src/lib/components/chat/Messages/CodeBlock.svelte146-217](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/components/chat/Messages/CodeBlock.svelte#L146-L217)

### 配置

代码执行通过环境变量和运行时配置进行设置：

| 配置项 | 环境变量 | 配置路径 | 默认值 |
| --- | --- | --- | --- |
| 启用代码执行 | `ENABLE_CODE_EXECUTION` | `app.state.config.ENABLE_CODE_EXECUTION` | `true` |
| 执行引擎 | `CODE_EXECUTION_ENGINE` | `app.state.config.CODE_EXECUTION_ENGINE` | `"pyodide"` |
| Jupyter URL | `CODE_EXECUTION_JUPYTER_URL` | `app.state.config.CODE_EXECUTION_JUPYTER_URL` | `""` |
| Jupyter 身份验证 | `CODE_EXECUTION_JUPYTER_AUTH` | `app.state.config.CODE_EXECUTION_JUPYTER_AUTH` | `""` |
| Jupyter 验证令牌 | `CODE_EXECUTION_JUPYTER_AUTH_TOKEN` | `app.state.config.CODE_EXECUTION_JUPYTER_AUTH_TOKEN` | `""` |
| Jupyter 验证密码 | `CODE_EXECUTION_JUPYTER_AUTH_PASSWORD` | `app.state.config.CODE_EXECUTION_JUPYTER_AUTH_PASSWORD` | `""` |
| Jupyter 超时时间 | `CODE_EXECUTION_JUPYTER_TIMEOUT` | `app.state.config.CODE_EXECUTION_JUPYTER_TIMEOUT` | `60` |

来源： [backend/open\_webui/main.py131-145](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L131-L145) [backend/open\_webui/main.py1049-1071](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L1049-L1071)

## 工具服务器集成

### MCP (模型上下文协议)

MCP 服务器通过标准化协议提供工具和资源。系统维护与已配置 MCP 服务器的连接：

```mermaid
flowchart TD
    TOOL_SERVER_CONNECTIONS["TOOL_SERVER_CONNECTIONS 环境变量"]
    TOOL_SERVERS["app.state.TOOL_SERVERS 服务器配置列表"]
    get_tools_fn["get_tools()"]
    MCPClient["MCPClient (每个服务器一个)"]
    event_caller_mcp["event_caller() {type: 'execute:tool', server: {...}}"]
    execute_mcp["在 MCP 服务器上执行"]
    parse_json["解析 JSON 数组"]
    iterate_servers["遍历 TOOL_SERVERS 中的每个服务器"]
    list_tools["list_tools()"]
    tool_specs["生成工具规范 {name, spec, direct=True, server: {...}}"]
    registry["添加到工具注册表"]
    chat_completion_tools_handler["chat_completion_tools_handler"]
    tool_detected["工具已选择且 direct=True?"]
    mcp_result["MCP 结果 [{type, text/data}]"]
    process_tool_result["process_tool_result() 提取文本, 图像, 音频"]

    TOOL_SERVER_CONNECTIONS --> parse_json
    parse_json --> TOOL_SERVERS
    TOOL_SERVERS --> get_tools_fn
    get_tools_fn --> iterate_servers
    iterate_servers --> MCPClient
    MCPClient --> list_tools
    list_tools --> tool_specs
    tool_specs --> registry
    registry --> chat_completion_tools_handler
    chat_completion_tools_handler --> tool_detected
    tool_detected -- 是 --> event_caller_mcp
    event_caller_mcp --> execute_mcp
    execute_mcp --> mcp_result
    mcp_result --> process_tool_result
```
**图表：MCP 服务器集成架构**

MCP 服务器通过 `TOOL_SERVER_CONNECTIONS` 以 JSON 数组形式配置。每个服务器提供的工具注册时 `direct=True`，这意味着它们是通过事件系统而非直接的可调用函数触发的。

来源： [backend/open\_webui/main.py700-702](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L700-L702) [backend/open\_webui/utils/middleware.py399-410](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L399-L410)

### MCP 结果处理

MCP 工具以结构化格式返回结果，需要特殊处理：

```json
# MCP 结果结构示例
[
    {"type": "text", "text": "结果内容"},
    {"type": "image", "mimeType": "image/png", "data": "base64..."},
    {"type": "audio", "mimeType": "audio/wav", "blob": "base64..."}
]
```
`process_tool_result` 函数通过以下方式处理 MCP 结果：

1.  遍历结果项列表。
2.  提取文本项（如果适用，尝试进行 JSON 解析）。
3.  通过 `get_file_url_from_base64` 将图像/音频项转换为文件 URL。
4.  为每个媒体项构建包含类型和 URL 的 `tool_result_files` 数组。

来源： [backend/open\_webui/utils/middleware.py233-264](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L233-L264)

## OpenAPI 工具集成

### OpenAPI 工具加载

OpenAPI 工具通过 OpenAPI 规范定义，并存储在工具注册表中：

```mermaid
flowchart TD
    openapi_spec["OpenAPI 规范 (JSON/YAML)"]
    tool_metadata["工具元数据 {id, name, meta}"]
    parse_openapi["解析 OpenAPI 规范"]
    extract_operations["提取操作 (路径 + 方法)"]
    generate_specs["为每个操作生成函数规范"]
    TOOLS_dict["app.state.TOOLS[tool_id]"]
    TOOL_CONTENTS_dict["app.state.TOOL_CONTENTS[tool_id]"]
    get_tools_fn["get_tools()"]
    update_spec["get_updated_tool_function() 修改规范以供过滤"]
    tools_registry["tools = {} {name: {spec, callable, type}}"]
    iterate_tools["遍历 TOOLS 中的每个工具"]
    add_to_registry["添加到 tools_registry"]
    return_tools["返回工具字典"]

    openapi_spec --> parse_openapi
    parse_openapi --> extract_operations
    extract_operations --> generate_specs
    generate_specs --> TOOLS_dict
    tool_metadata --> TOOL_CONTENTS_dict
    TOOLS_dict --> get_tools_fn
    TOOL_CONTENTS_dict --> get_tools_fn
    get_tools_fn --> iterate_tools
    iterate_tools --> update_spec
    update_spec --> add_to_registry
    add_to_registry --> tools_registry
    tools_registry --> return_tools
```
**图表：OpenAPI 工具注册流程**

OpenAPI 工具存储为将工具 ID 映射到其规范的字典。`get_tools()` 函数处理这些规范，并添加执行向 OpenAPI 端点发送 HTTP 请求的可调用函数。

来源： [backend/open\_webui/utils/tools.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/tools.py) [backend/open\_webui/main.py813-817](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L813-L817)

### 外部工具调用

OpenAPI 工具通过向外部端点发送 HTTP 请求来执行。工具的可调用函数：

1.  根据 OpenAPI 规范和参数构造 HTTP 请求。
2.  执行向外部端点的请求。
3.  将响应体和请求头作为元组返回。
4.  `process_tool_result` 处理该元组以提取内联内容。

当工具返回带有 `Content-Disposition: inline` 的请求头时，响应将被视为可嵌入内容（HTML iframe 或位置重定向）。

来源： [backend/open\_webui/utils/middleware.py186-229](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L186-L229)

## 工具访问控制

工具通过 `access_control` 字段支持细粒度的访问控制：

```mermaid
flowchart TD
    tool["工具/函数"]
    access_control["access_control {read: {}, write: {}}"]
    has_access_fn["has_access()(user, tool.access_control, 'read')"]
    check_role["用户角色？"]
    check_user_id["用户 ID 是否在 user_ids 中？"]
    check_group["用户组是否与 group_ids 有交集？"]
    get_tools_fn["get_tools(user)"]
    filter_tools["按 access_control 过滤"]
    filtered_registry["经过过滤的工具注册表"]
    allow["允许"]
    deny["拒绝"]

    tool --> access_control
    access_control --> has_access_fn
    has_access_fn --> check_role
    check_role -- 管理员 --> allow
    check_role -- 普通用户 --> check_user_id
    check_user_id -- 是 --> allow
    check_user_id -- 否 --> check_group
    check_group -- 是 --> allow
    check_group -- 否 --> deny
    get_tools_fn --> filter_tools
    filter_tools --> has_access_fn
    has_access_fn --> filtered_registry
```
**图表：工具访问控制流程**

`get_tools()` 函数根据用户权限过滤工具。只有用户拥有“读取 (read)”权限的工具才会被包含在返回给工具执行系统的注册表中。

来源： [backend/open\_webui/utils/tools.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/tools.py) [backend/open\_webui/utils/access\_control.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/access_control.py)

## 错误处理与重试逻辑

工具执行系统包含全面的错误处理：

| 错误类型 | 处理策略 | 结果 |
| --- | --- | --- |
| **未找到工具** | 跳过工具调用 | 返回空的 `body, {}` |
| **无效参数** | 按规范过滤参数 | 仅传递允许的参数 |
| **执行异常** | 捕获并转换为字符串 | `tool_result = str(e)` |
| **HTML 解析错误** | 解码为 UTF-8 字符串 | 回退到文本内容 |
| **JSON 解析错误** | 返回原始响应 | 原样包含在工具结果中 |

针对代码执行的具体处理：

-   **Pyodide 超时**：60 秒限制，终止 worker。
-   **Jupyter 超时**：通过 `CODE_EXECUTION_JUPYTER_TIMEOUT` 配置。
-   **导入错误**：在 stderr 中捕获，显示给用户。

来源： [backend/open\_webui/utils/middleware.py415-416](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py#L415-L416) [src/lib/components/chat/Messages/CodeBlock.svelte247-253](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/components/chat/Messages/CodeBlock.svelte#L247-L253)
