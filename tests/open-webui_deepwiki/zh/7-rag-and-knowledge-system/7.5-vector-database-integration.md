# 向量数据库集成

相关源文件

-   [.github/workflows/integration-test.disabled](https://github.com/open-webui/open-webui/blob/a7271532/.github/workflows/integration-test.disabled)
-   [backend/open\_webui/config.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/config.py)
-   [backend/open\_webui/main.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py)
-   [backend/open\_webui/retrieval/loaders/datalab\_marker.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/datalab_marker.py)
-   [backend/open\_webui/retrieval/loaders/external\_document.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/external_document.py)
-   [backend/open\_webui/retrieval/loaders/external\_web.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/external_web.py)
-   [backend/open\_webui/retrieval/loaders/main.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/main.py)
-   [backend/open\_webui/retrieval/loaders/mineru.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/mineru.py)
-   [backend/open\_webui/retrieval/loaders/mistral.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/loaders/mistral.py)
-   [backend/open\_webui/retrieval/utils.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py)
-   [backend/open\_webui/routers/retrieval.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/routers/retrieval.py)
-   [backend/open\_webui/storage/provider.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/storage/provider.py)
-   [backend/open\_webui/test/apps/webui/storage/test\_provider.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/test/apps/webui/storage/test_provider.py)
-   [backend/open\_webui/utils/middleware.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/middleware.py)
-   [backend/requirements-min.txt](https://github.com/open-webui/open-webui/blob/a7271532/backend/requirements-min.txt)
-   [backend/requirements.txt](https://github.com/open-webui/open-webui/blob/a7271532/backend/requirements.txt)
-   [docker-compose.playwright.yaml](https://github.com/open-webui/open-webui/blob/a7271532/docker-compose.playwright.yaml)
-   [pyproject.toml](https://github.com/open-webui/open-webui/blob/a7271532/pyproject.toml)
-   [src/lib/apis/retrieval/index.ts](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/apis/retrieval/index.ts)
-   [src/lib/components/admin/Settings/Documents.svelte](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/components/admin/Settings/Documents.svelte)
-   [src/lib/components/admin/Settings/WebSearch.svelte](https://github.com/open-webui/open-webui/blob/a7271532/src/lib/components/admin/Settings/WebSearch.svelte)
-   [uv.lock](https://github.com/open-webui/open-webui/blob/a7271532/uv.lock)

本文档描述了 Open WebUI 中的向量数据库抽象层，该层为在多个向量数据库后端之间存储和检索文档嵌入提供了一个统一接口。该层支持语义搜索，并构成了 RAG（检索增强生成）系统的核心存储机制。

有关存储之前如何生成嵌入的信息，请参阅 [嵌入生成](/open-webui/open-webui/7.4-embedding-generation)。有关检索策略和混合搜索的详情，请参阅 [检索策略](/open-webui/open-webui/7.6-retrieval-strategies)。有关整个 RAG 流水线的概览，请参阅 [RAG 与知识库系统](/open-webui/open-webui/7-rag-and-knowledge-system)。

---

## 受支持的向量数据库

Open WebUI 通过可插拔架构支持多种向量数据库后端。系统使用工厂模式根据配置实例化适当的客户端。

### 可用后端

| 数据库 | 软件包 | 所需配置 | 用例 |
| --- | --- | --- | --- |
| **ChromaDB** | `chromadb==1.3.7` | 无 (默认) | 本地开发、单节点部署 |
| **Qdrant** | `qdrant-client==1.16.2` | `QDRANT_URL`, `QDRANT_API_KEY` | 生产环境、分布式部署 |
| **Milvus** | `pymilvus==2.6.5` | `MILVUS_URI` | 大规模生产、GPU 加速搜索 |
| **Weaviate** | `weaviate-client==4.19.0` | `WEAVIATE_URL`, `WEAVIATE_API_KEY` | 云原生部署 |
| **OpenSearch** | `opensearch-py==3.1.0` | `OPENSEARCH_URI` | 企业级搜索、AWS 部署 |
| **PGVector** | `pgvector==0.4.2`, `psycopg2-binary` | `DATABASE_URL` (PostgreSQL) | 基于 PostgreSQL 的部署 |
| **Pinecone** | `pinecone==6.0.2` | `PINECONE_API_KEY` | 无服务器 (Serverless) 向量搜索 |
| **Oracle** | `oracledb==3.4.1` | Oracle 连接参数 | Oracle 数据库集成 |

**来源：**

-   [backend/requirements.txt54-56](https://github.com/open-webui/open-webui/blob/a7271532/backend/requirements.txt#L54-L56)
-   [pyproject.toml152-158](https://github.com/open-webui/open-webui/blob/a7271532/pyproject.toml#L152-L158)

---

## 向量数据库客户端架构

系统使用工厂模式将向量数据库操作抽象在一个统一的 `VECTOR_DB_CLIENT` 接口之后。这种设计允许应用程序在不更改代码的情况下切换向量数据库后端。

### 工厂模式实现

**图表：向量数据库客户端工厂架构**

工厂在应用程序启动时初始化，并提供一个在整个应用程序中使用的单例客户端实例。

**来源：**

-   [backend/open\_webui/config.py22](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/config.py#L22-L22)
-   [backend/open\_webui/retrieval/vector/factory.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/vector/factory.py) (引用)
-   [backend/open\_webui/routers/retrieval.py44](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/routers/retrieval.py#L44-L44)

---

## 客户端接口操作

无论底层数据库后端如何，`VECTOR_DB_CLIENT` 都提供一致的接口。所有向量数据库实现都必须支持以下核心操作：

### 集合管理

```mermaid
flowchart TD
    Create["create_collection()"]
    Get["get()"]
    Delete["delete_collection()"]
    Has["has_collection()"]
    Insert["insert()"]
    Search["search()"]
    Update["update()"]

    Create --> Insert
    Insert --> Search
    Search --> Get
    Get --> Update
    Update --> Delete
```
**图表：向量数据库操作流程**

### 关键操作

| 操作 | 用途 | 返回类型 |
| --- | --- | --- |
| `create_collection(collection_name, vectors)` | 使用向量初始化新集合 | Collection |
| `has_collection(collection_name)` | 检查集合是否存在 | bool |
| `delete_collection(collection_name)` | 移除集合及其所有向量 | None |
| `search(collection_name, vectors, limit)` | 执行相似度搜索 | QueryResult |
| `get(collection_name)` | 从集合中检索所有向量 | GetResult |
| `insert(collection_name, vectors, documents, metadatas)` | 添加新向量 | None |
| `upsert(collection_name, vectors, documents, metadatas, ids)` | 插入或更新向量 | None |

**来源：**

-   [backend/open\_webui/retrieval/utils.py89-168](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L89-L168)
-   [backend/open\_webui/retrieval/vector/main.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/vector/main.py) (引用)

---

## 配置与初始化

### 环境变量

向量数据库后端通过 `VECTOR_DB` 环境变量选择：

```bash
# ChromaDB (默认)
VECTOR_DB=chroma

# Qdrant
VECTOR_DB=qdrant
QDRANT_URL=http://localhost:6333
QDRANT_API_KEY=your-api-key

# Milvus
VECTOR_DB=milvus
MILVUS_URI=http://localhost:19530

# PGVector (需要带 pgvector 扩展的 PostgreSQL)
VECTOR_DB=pgvector
DATABASE_URL=postgresql://user:pass@localhost/dbname
```
### 应用启动初始化

向量数据库客户端在应用程序启动期间的生命周期 (lifespan) 上下文中初始化：

> **[Mermaid sequence]**
> *(图表结构无法解析)*

**图表：向量数据库初始化序列**

**来源：**

-   [backend/open\_webui/main.py570-632](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L570-L632)
-   [backend/open\_webui/config.py1-40](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/config.py#L1-L40)

---

## 查询操作

### 标准向量搜索

标准向量搜索使用嵌入向量执行余弦相似度搜索：

```mermaid
flowchart TD
    Query["用户查询文本"]
    CollectionName["集合名称"]
    EmbedFunc["EMBEDDING_FUNCTION"]
    QueryEmbed["查询嵌入向量"]
    VectorDB["VECTOR_DB_CLIENT.search()"]
    Result["QueryResult{ids, metadatas, documents, distances}"]
    TopK["前 K 个结果"]
    Threshold["相关性阈值过滤"]
    Sorted["按距离排序"]

    Query --> EmbedFunc
    EmbedFunc --> QueryEmbed
    QueryEmbed --> VectorDB
    CollectionName --> VectorDB
    VectorDB --> Result
    Result --> TopK
    TopK --> Threshold
    Threshold --> Sorted
```
**图表：标准向量搜索流程**

`retrieval/utils.py` 中的 `query_doc()` 函数实现了标准向量搜索：

```python
def query_doc(
    collection_name: str,
    query_embedding: list[float],
    k: int,
    user: UserModel = None
):
    result = VECTOR_DB_CLIENT.search(
        collection_name=collection_name,
        vectors=[query_embedding],
        limit=k,
    )
    return result
```
**来源：**

-   [backend/open\_webui/retrieval/utils.py136-154](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L136-L154)
-   [backend/open\_webui/config.py836-840](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/config.py#L836-L840)

### 集合检索

全量集合检索用于混合搜索和重排序：

```python
def get_doc(collection_name: str, user: UserModel = None):
    result = VECTOR_DB_CLIENT.get(collection_name=collection_name)
    return result
```
**来源：**

-   [backend/open\_webui/retrieval/utils.py156-168](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L156-L168)

---

## 与 RAG 流水线的集成

向量数据库与 RAG 系统中的多个组件集成：

```mermaid
flowchart TD
    Upload["文件上传"]
    Extract["内容提取 见 7.2"]
    Split["文本分割 见 7.3"]
    Embed["嵌入生成 见 7.4"]
    VectorDB["VECTOR_DB_CLIENT"]
    Collections["集合 (每个文件/知识库一个)"]
    UserQuery["用户查询"]
    QueryEmbed["查询嵌入 EMBEDDING_FUNCTION"]
    Search["向量搜索或混合搜索"]
    Rerank["可选的重排序 见 7.6"]
    Context["检索到的上下文"]
    LLM["带有上下文的 LLM"]
    Response["生成的响应"]

    Upload --> Extract
    Extract --> Split
    Split --> Embed
    Embed --> VectorDB
    VectorDB --> Collections
    UserQuery --> QueryEmbed
    QueryEmbed --> Search
    Collections --> Search
    Search --> Rerank
    Rerank --> Context
    Context --> LLM
    LLM --> Response
```
**图表：RAG 流水线中的向量数据库**

### 文件与知识库集合管理

每个上传的文件或知识库项都会在向量数据库中创建自己的集合：

-   **文件集合**：使用文件元数据哈希命名。
-   **知识库集合**：使用知识库 ID 命名。
-   **集合元数据**：与每个向量一起存储，包括源文件、分块位置、时间戳。

**来源：**

-   [backend/open\_webui/routers/retrieval.py1-118](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/routers/retrieval.py#L1-L118)
-   [backend/open\_webui/retrieval/utils.py386-401](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L386-L401)

---

## 查询结果与数据结构

### GetResult 结构

全量集合检索返回一个 `GetResult` 对象：

```text
GetResult:
    ids: [[str, ...]]          # 文档 ID
    documents: [[str, ...]]    # 文本内容
    metadatas: [[dict, ...]]   # 每个分块的元数据
```
### QueryResult 结构

搜索操作返回一个 `QueryResult` 对象：

```text
QueryResult:
    ids: [[str, ...]]          # 文档 ID
    documents: [[str, ...]]    # 文本内容
    metadatas: [[dict, ...]]   # 元数据
    distances: [[float, ...]]  # 相似度分数 (越高表示越相似)
```
### 元数据字段

随每个向量一起存储的标准元数据：

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| `name` | string | 源文件名 |
| `title` | string | 文档标题 (如果可用) |
| `source` | string | 文件路径或 URL |
| `headings` | list | 章节标题 (来自 Markdown 分割器) |
| `snippet` | string | 搜索结果片段 |
| `created_at` | timestamp | 文档创建时间 |
| `file_id` | string | 引用 Files 表 |

**来源：**

-   [backend/open\_webui/retrieval/utils.py170-206](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L170-L206)
-   [backend/open\_webui/retrieval/vector/main.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/vector/main.py) (引用)

---

## 多集合查询操作

系统支持同时查询多个集合，以实现全面的知识检索：

```mermaid
flowchart TD
    Query["用户查询"]
    Collections["集合名称列表"]
    C1["查询集合 1"]
    C2["查询集合 2"]
    CN["查询集合 N"]
    Dedupe["按文档哈希去重"]
    Merge["合并结果"]
    Sort["按距离排序"]
    TopK["选取前 K 个"]

    Query --> C1
    Query --> C2
    Query --> CN
    Collections --> C1
    Collections --> C2
    Collections --> CN
    C1 --> Dedupe
    C2 --> Dedupe
    CN --> Dedupe
    Dedupe --> Merge
    Merge --> Sort
    Sort --> TopK
```
**图表：多集合查询流程**

`merge_and_sort_query_results()` 函数合并来自多个集合的结果：

-   使用 SHA-256 内容哈希对文档进行去重。
-   对重复项保留最好（最高）的距离分数。
-   按相关性排序并返回前 K 个结果。

**来源：**

-   [backend/open\_webui/retrieval/utils.py339-384](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L339-L384)
-   [backend/open\_webui/retrieval/utils.py318-337](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L318-L337)

---

## 通过管理 API 进行配置管理

向量数据库配置可以通过管理员 API 端点进行查询和更新：

### GET `/api/v1/retrieval/config`

返回当前的 RAG 和向量数据库配置，包括：

-   `ENABLE_RAG_HYBRID_SEARCH`：是否启用混合搜索。
-   `TOP_K`：要检索的结果数量。
-   `TOP_K_RERANKER`：重排序后的结果数量。
-   `RELEVANCE_THRESHOLD`：最小相似度阈值。
-   `HYBRID_BM25_WEIGHT`：混合搜索中 BM25 的权重。

### POST `/api/v1/retrieval/config/update`

更新 RAG 配置。更改将持久化到数据库并立即应用。

### POST `/api/v1/retrieval/reset`

删除向量数据库中的所有集合。这是一个破坏性操作，需要管理员权限。

**来源：**

-   [backend/open\_webui/routers/retrieval.py443-532](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/routers/retrieval.py#L443-L532)
-   [backend/open\_webui/config.py224-284](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/config.py#L224-L284)

---

## 集合元数据与访问控制

集合通过元数据与文件和知识库相关联：

```mermaid
flowchart TD
    Files["Files 表"]
    Knowledge["Knowledge 表"]
    Collections["集合"]
    Vectors["向量嵌入"]
    Meta["分块元数据"]
    Users["Users 表"]
    Groups["Groups 表"]
    Access["has_access()"]

    Files --> Collections
    Knowledge --> Collections
    Collections --> Vectors
    Collections --> Meta
    Users --> Access
    Groups --> Access
    Access --> Collections
```
**图表：集合元数据与访问控制**

访问控制在查询时使用 `has_access()` 工具函数强制执行，该函数检查：

-   文件/知识库的用户所有权。
-   组数成员权限。
-   管理员绕过标志。

**来源：**

-   [backend/open\_webui/retrieval/utils.py26-36](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/retrieval/utils.py#L26-L36)
-   [backend/open\_webui/utils/access\_control.py](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/utils/access_control.py) (引用)

---

## 测试与验证

向量数据库提供者通过一套全面的测试套件进行验证，这些套件验证了：

### 测试覆盖范围

| 测试项 | 目的 | 文件 |
| --- | --- | --- |
| 提供者实例化 | 验证工厂模式 | `test_provider.py` |
| 上传操作 | 测试向量插入 | 存储提供者测试 |
| 检索操作 | 测试搜索准确性 | 集成测试 |
| 集合管理 | 测试 CRUD 操作 | 单元测试 |

测试套件对外部依赖使用模拟 (mocking)，并支持本地和基于云的向量数据库。

**来源：**

-   [backend/open\_webui/test/apps/webui/storage/test\_provider.py1-308](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/test/apps/webui/storage/test_provider.py#L1-L308)
-   [.github/workflows/integration-test.disabled1-174](https://github.com/open-webui/open-webui/blob/a7271532/.github/workflows/integration-test.disabled#L1-L174)

---

## 性能考量

### 连接池 (Connection Pooling)

每个向量数据库客户端管理自己的连接池：

-   ChromaDB：持久化的本地客户端。
-   Qdrant：具有连接重用功能的 HTTP 客户端。
-   Milvus：gRPC 连接池。
-   Weaviate：具有会话管理的 REST API。

### 批处理操作

大型文档集合分批处理以避免内存问题：

-   嵌入批处理大小：可通过 `RAG_EMBEDDING_BATCH_SIZE` 配置。
-   插入批处理大小：取决于具体的数据库限制。
-   查询限制：由 `TOP_K` 配置强制执行。

### 缓存策略

系统在多个层级使用 Redis 进行缓存：

-   配置缓存 (AppConfig)。
-   查询结果缓存 (可选)。
-   嵌入缓存 (针对重复查询)。

**来源：**

-   [backend/open\_webui/config.py224-284](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/config.py#L224-L284)
-   [backend/open\_webui/routers/retrieval.py256-261](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/routers/retrieval.py#L256-L261)
-   [backend/open\_webui/main.py586-656](https://github.com/open-webui/open-webui/blob/a7271532/backend/open_webui/main.py#L586-L656)
