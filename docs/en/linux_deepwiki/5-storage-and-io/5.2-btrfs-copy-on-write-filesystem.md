# Btrfs Copy-on-Write Filesystem

Relevant source files

-   [fs/afs/callback.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/afs/callback.c)
-   [fs/btrfs/accessors.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/accessors.h)
-   [fs/btrfs/backref.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/backref.c)
-   [fs/btrfs/bio.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/bio.c)
-   [fs/btrfs/bio.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/bio.h)
-   [fs/btrfs/block-group.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/block-group.c)
-   [fs/btrfs/block-group.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/block-group.h)
-   [fs/btrfs/btrfs\_inode.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/btrfs_inode.h)
-   [fs/btrfs/compression.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/compression.c)
-   [fs/btrfs/compression.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/compression.h)
-   [fs/btrfs/ctree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ctree.c)
-   [fs/btrfs/defrag.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/defrag.c)
-   [fs/btrfs/delayed-inode.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/delayed-inode.c)
-   [fs/btrfs/delayed-inode.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/delayed-inode.h)
-   [fs/btrfs/delayed-ref.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/delayed-ref.c)
-   [fs/btrfs/delayed-ref.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/delayed-ref.h)
-   [fs/btrfs/dev-replace.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/dev-replace.c)
-   [fs/btrfs/dir-item.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/dir-item.c)
-   [fs/btrfs/direct-io.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/direct-io.c)
-   [fs/btrfs/disk-io.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c)
-   [fs/btrfs/disk-io.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.h)
-   [fs/btrfs/extent-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c)
-   [fs/btrfs/extent-tree.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.h)
-   [fs/btrfs/extent\_io.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c)
-   [fs/btrfs/extent\_io.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.h)
-   [fs/btrfs/file-item.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/file-item.c)
-   [fs/btrfs/file-item.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/file-item.h)
-   [fs/btrfs/file.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/file.c)
-   [fs/btrfs/free-space-cache.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/free-space-cache.c)
-   [fs/btrfs/free-space-cache.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/free-space-cache.h)
-   [fs/btrfs/free-space-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/free-space-tree.c)
-   [fs/btrfs/fs.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/fs.h)
-   [fs/btrfs/inode-item.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode-item.c)
-   [fs/btrfs/inode.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c)
-   [fs/btrfs/ioctl.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ioctl.c)
-   [fs/btrfs/messages.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/messages.c)
-   [fs/btrfs/messages.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/messages.h)
-   [fs/btrfs/misc.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/misc.h)
-   [fs/btrfs/ordered-data.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ordered-data.c)
-   [fs/btrfs/qgroup.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/qgroup.c)
-   [fs/btrfs/raid-stripe-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/raid-stripe-tree.c)
-   [fs/btrfs/raid56.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/raid56.c)
-   [fs/btrfs/raid56.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/raid56.h)
-   [fs/btrfs/ref-verify.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ref-verify.c)
-   [fs/btrfs/reflink.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/reflink.c)
-   [fs/btrfs/relocation.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/relocation.c)
-   [fs/btrfs/relocation.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/relocation.h)
-   [fs/btrfs/root-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/root-tree.c)
-   [fs/btrfs/scrub.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/scrub.c)
-   [fs/btrfs/send.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/send.c)
-   [fs/btrfs/space-info.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/space-info.c)
-   [fs/btrfs/space-info.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/space-info.h)
-   [fs/btrfs/subpage.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/subpage.c)
-   [fs/btrfs/subpage.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/subpage.h)
-   [fs/btrfs/super.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/super.c)
-   [fs/btrfs/transaction.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/transaction.c)
-   [fs/btrfs/tree-checker.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-checker.c)
-   [fs/btrfs/tree-log.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c)
-   [fs/btrfs/tree-log.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.h)
-   [fs/btrfs/volumes.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/volumes.c)
-   [fs/btrfs/volumes.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/volumes.h)
-   [fs/btrfs/xattr.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/xattr.c)
-   [fs/btrfs/zoned.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/zoned.c)
-   [include/uapi/linux/btrfs.h](https://github.com/torvalds/linux/blob/fcb70a56/include/uapi/linux/btrfs.h)

## Purpose and Scope

This document describes the Btrfs (B-tree filesystem) implementation in the Linux kernel, focusing on its copy-on-write (COW) architecture, B-tree-based storage structures, extent management, and advanced features including snapshots, RAID, compression, and data integrity mechanisms. Btrfs is designed as a modern filesystem with built-in volume management, checksumming, and support for advanced storage scenarios including zoned devices.

For information about the VFS layer that Btrfs integrates with, see [Virtual File System Layer](/torvalds/linux/5.2-btrfs-copy-on-write-filesystem). For flash-optimized filesystems, see [F2FS Flash Filesystem](#5.3.1). For layered filesystems that can use Btrfs as backing storage, see [OverlayFS and Layered Filesystems](#5.3.3).

## Architecture Overview

Btrfs implements a copy-on-write B-tree filesystem with integrated volume management. The architecture consists of multiple interconnected B-trees managing different aspects of the filesystem, with all modifications using COW semantics.

### High-Level Component Structure

```mermaid
flowchart TD
    VFS["VFS Layerfile_operationsinode_operations"]
    Inode["Inode Layerfs/btrfs/inode.cstruct btrfs_inodebtrfs_file_operations"]
    CTree["B-tree Managementfs/btrfs/ctree.cbtrfs_search_slot()struct btrfs_path"]
    ExtentTree["Extent Treefs/btrfs/extent-tree.cbtrfs_reserve_extent()__btrfs_free_extent()"]
    TreeLog["Tree Logfs/btrfs/tree-log.cbtrfs_log_inode()btrfs_sync_log()"]
    ExtentIO["Extent I/Ofs/btrfs/extent_io.cstruct extent_buffersubmit_one_bio()"]
    Bio["Bio Layerfs/btrfs/bio.cstruct btrfs_biobtrfs_submit_bbio()"]
    Compression["Compressionfs/btrfs/compression.cbtrfs_compress_folios()compress_file_range()"]
    Volumes["Volume Managerfs/btrfs/volumes.cstruct btrfs_io_contextbtrfs_map_bio()"]
    Snapshot["Snapshotsbtrfs_copy_root()COW subvolumes"]
    RAID["RAID Enginefs/btrfs/raid56.cstruct btrfs_raid_bioRAID 0/1/5/6/10"]
    QGroup["Quota Groupsfs/btrfs/qgroup.cstruct btrfs_qgroup"]
    Zoned["Zoned Devicefs/btrfs/zoned.cbtrfs_zoned_device_info"]
    DiskIO["Disk I/Ofs/btrfs/disk-io.cread_tree_block()btree_csum_one_bio()"]
    BlockGroup["Block Groupsfs/btrfs/block-group.cstruct btrfs_block_group"]

    VFS --> Inode
    Inode --> CTree
    Inode --> ExtentIO
    Inode --> TreeLog
    CTree --> ExtentTree
    ExtentIO --> Bio
    ExtentIO --> Compression
    Bio --> Volumes
    Volumes --> RAID
    Volumes --> Zoned
    ExtentTree --> BlockGroup
    BlockGroup --> DiskIO
    TreeLog --> CTree
    Snapshot --> CTree
    QGroup --> ExtentTree
```
Sources: [fs/btrfs/inode.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L1-L100) [fs/btrfs/ctree.c1-50](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ctree.c#L1-L50) [fs/btrfs/extent-tree.c1-50](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c#L1-L50) [fs/btrfs/extent\_io.c1-50](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L1-L50) [fs/btrfs/bio.c1-50](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/bio.c#L1-L50) [fs/btrfs/tree-log.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c#L1-L100)

## Core Data Structures

### B-tree Management (ctree)

Btrfs uses multiple B-trees to organize filesystem metadata. The central tree structure is managed by `ctree.c`, which provides search, insertion, and deletion operations.

**Key B-tree Types:**

| Tree Type | Purpose | Root Location |
| --- | --- | --- |
| FS Tree | File and directory metadata | Per-subvolume |
| Extent Tree | Extent allocation tracking | Global |
| Chunk Tree | Device extent mapping | Global |
| Device Tree | Device information | Global |
| Root Tree | Subvolume root pointers | Global |
| Log Tree | Fast fsync operations | Per-subvolume |
| Checksum Tree | Data checksums | Global |

**Primary B-tree Operations:**

```mermaid
flowchart TD
    Search["btrfs_search_slot()fs/btrfs/ctree.c"]
    Insert["btrfs_insert_empty_item()fs/btrfs/ctree.c"]
    Delete["btrfs_del_item()fs/btrfs/ctree.c"]
    Split["split_leaf()split_node()fs/btrfs/ctree.c:29-40"]
    COW["__btrfs_cow_block()ctree.cCopy-on-write node"]
    ExtentBuffer["struct extent_bufferextent_io.cIn-memory tree node"]
    BtrfsPath["struct btrfs_pathTree traversal state"]

    Search --> Split
    Insert --> Split
    Insert --> COW
    Delete --> Search
    Search --> ExtentBuffer
    Insert --> ExtentBuffer
    Delete --> ExtentBuffer
    Search --> BtrfsPath
    Insert --> BtrfsPath
    Delete --> BtrfsPath
```
The `struct btrfs_path` is used for tree traversal, maintaining locks and references to tree nodes at each level:

```
struct btrfs_path
├── nodes[BTRFS_MAX_LEVEL] - extent_buffer pointers for each tree level
├── slots[BTRFS_MAX_LEVEL] - current slot in each node
├── locks[BTRFS_MAX_LEVEL] - lock state (read/write) for each level
└── Functions: btrfs_alloc_path(), btrfs_free_path(), btrfs_release_path()
```
Sources: [fs/btrfs/ctree.c27-175](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ctree.c#L27-L175) [fs/btrfs/ctree.c138-153](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ctree.c#L138-L153) [fs/btrfs/ctree.c160-175](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ctree.c#L160-L175)

### Extent Buffers

Extent buffers (`struct extent_buffer` in `extent_io.c`) represent in-memory tree nodes and are the fundamental unit for B-tree operations. They are managed by the extent I/O subsystem.

```mermaid
flowchart TD
    EB["struct extent_bufferfs/btrfs/extent_io.c:222-241"]
    Folios["folios[]Page cache storagefolio_size, folio_shift"]
    Metadata["Tree Metadatastart (bytenr)len (nodesize)btrfs_header_level()btrfs_header_generation()"]
    Lock["Lockingread_lock, write_lockspinning_readers/writers"]
    Ref["Reference Countingrefcount_t refsatomic operations"]
    Cache["extent_buffer_cachekmem_cacheextent_buffer_init_cachep()"]
    ReadOp["btrfs_read_extent_buffer()fs/btrfs/disk-io.c:223-262read_extent_buffer_pages()"]
    WriteOp["btree_csum_one_bio()fs/btrfs/disk-io.c:267-338Checksum tree block"]
    Validate["btrfs_validate_extent_buffer()fs/btrfs/disk-io.c:366-476csum_tree_block()btrfs_check_leaf/node()"]
    Find["find_extent_buffer()Lookup in radix tree"]
    Alloc["alloc_extent_buffer()fs/btrfs/disk-io.c:607-644Allocate new buffer"]

    EB --> Folios
    EB --> Metadata
    EB --> Lock
    EB --> Ref
    Cache --> EB
    EB --> ReadOp
    EB --> WriteOp
    ReadOp --> Validate
    Cache --> Find
    Cache --> Alloc
```
Sources: [fs/btrfs/extent\_io.c222-241](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L222-L241) [fs/btrfs/disk-io.c223-262](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L223-L262) [fs/btrfs/disk-io.c267-338](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L267-L338) [fs/btrfs/disk-io.c366-476](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L366-L476) [fs/btrfs/disk-io.c607-644](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L607-L644)

### Inode Structure

The `struct btrfs_inode` (defined in `fs/btrfs/btrfs_inode.h`) extends the VFS inode with Btrfs-specific metadata:

```
struct btrfs_inode (btrfs_inode.h:45-350)
├── vfs_inode - Standard VFS inode (struct inode)
├── root - struct btrfs_root pointer to containing subvolume
├── io_tree - struct extent_io_tree for extent state tracking
│   ├── EXTENT_DELALLOC - Delayed allocation ranges
│   ├── EXTENT_LOCKED - Locked ranges during I/O
│   ├── EXTENT_UPTODATE - Cached data
│   └── EXTENT_DIRTY - Dirty ranges
├── file_extent_tree - struct extent_io_tree for file extent mapping
├── ordered_tree - struct rb_root for ordered extent tracking
├── disk_i_size - u64 size on disk (may lag i_size during writes)
├── flags - u32 inode flags:
│   ├── BTRFS_INODE_NODATACOW - Don't COW data
│   ├── BTRFS_INODE_COMPRESS - Enable compression
│   ├── BTRFS_INODE_NOCOMPRESS - Disable compression
│   ├── BTRFS_INODE_PREALLOC - Preallocated extents
│   └── BTRFS_INODE_SYNC - Synchronous I/O
├── delalloc_bytes - u64 bytes in delalloc state
├── csum_bytes - u64 bytes needing checksum
├── defrag_compress - Compression for defrag
└── ordered_extents - List of struct btrfs_ordered_extent
```
Sources: [fs/btrfs/btrfs\_inode.h1-350](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/btrfs_inode.h#L1-L350)

## Copy-on-Write Mechanism

Btrfs implements copy-on-write at multiple levels: data extents, metadata blocks, and entire B-tree nodes. This enables snapshots, crash recovery, and efficient cloning.

### COW Data Write Path

```mermaid
flowchart TD
    Write["User write()file.c"]
    Dirty["btrfs_dirty_folio()file.c:70-120"]
    Delalloc["btrfs_set_extent_delalloc()Mark range as delalloc"]
    Writeback["Writeback triggered"]
    CowRange["cow_file_range()or run_delalloc_cow()"]
    ReserveExtent["btrfs_reserve_extent()extent-tree.cAllocate new extent"]
    CreateOrdered["btrfs_alloc_ordered_extent()Track ordered write"]
    SubmitBio["btrfs_submit_bbio()Submit I/O"]
    Finish["btrfs_finish_ordered_extent()Update metadata after I/O"]
    UpdateExtentTree["Insert file extent itemUpdate extent tree"]

    Write --> Dirty
    Dirty --> Delalloc
    Delalloc --> Writeback
    Writeback --> CowRange
    CowRange --> ReserveExtent
    ReserveExtent --> CreateOrdered
    CreateOrdered --> SubmitBio
    SubmitBio --> Finish
    Finish --> UpdateExtentTree
```
**COW Flow for File Data:**

1.  **Delalloc Phase** [fs/btrfs/inode.c77-120](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L77-L120) - User writes mark pages dirty and set the `EXTENT_DELALLOC` bit in the `io_tree`
2.  **Extent Reservation** [fs/btrfs/extent-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c) - During writeback, allocate new extents without modifying old data
3.  **Ordered Extent Creation** - Track the write with `btrfs_ordered_extent` to maintain consistency
4.  **Bio Submission** [fs/btrfs/bio.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/bio.c) - Write data to new location
5.  **Metadata Update** - After successful write, insert new file extent item in transaction

### COW Metadata Write Path

```mermaid
flowchart TD
    ModifyTree["Modify B-treebtrfs_search_slot(trans, root, key, path, 1, 1)fs/btrfs/ctree.cins_len=1, cow=1"]
    CheckCOW["Check if COW neededtree_mod_log_needs_log()"]
    COWNode["__btrfs_cow_block()fs/btrfs/ctree.c:242-292Copy-on-write tree node"]
    AllocTree["btrfs_alloc_tree_block()fs/btrfs/extent-tree.cAllocate new tree blockReserve extent"]
    CopyContent["copy_extent_buffer_full()Copy entire node contentto new location"]
    UpdateHeader["btrfs_set_header_bytenr()btrfs_set_header_generation()Update metadata"]
    UpdateParent["Update parent nodePoint to new bytenrbtrfs_set_node_blockptr()"]
    OldNode["Old node remainsReferenced by snapshotsPrevious transactions"]
    AddDelayedRef["btrfs_add_delayed_extent_op()fs/btrfs/delayed-ref.cQueue old extent free"]
    PinExtent["btrfs_pin_extent()Pin until transaction commits"]
    SetDirty["btrfs_mark_buffer_dirty()Mark new node dirtyfor writeback"]

    ModifyTree --> CheckCOW
    CheckCOW --> COWNode
    COWNode --> AllocTree
    AllocTree --> CopyContent
    CopyContent --> UpdateHeader
    UpdateHeader --> UpdateParent
    UpdateParent --> OldNode
    OldNode --> AddDelayedRef
    AddDelayedRef --> PinExtent
    UpdateHeader --> SetDirty
```
The COW mechanism for metadata ensures that:

-   Snapshots see a consistent point-in-time view via unchanged old tree blocks
-   Crash recovery can roll back to last committed transaction stored in superblock
-   Concurrent readers can access old versions while writers modify new copies
-   Old extents are freed only after new transaction commits via delayed references

Sources: [fs/btrfs/ctree.c242-292](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ctree.c#L242-L292) [fs/btrfs/extent-tree.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c#L1-L100) [fs/btrfs/delayed-ref.c1-50](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/delayed-ref.c#L1-L50)

## Extent Management

Btrfs manages disk space through extents tracked in the extent allocation tree. Each extent represents a contiguous range of disk blocks.

### Extent Allocation Tree Structure

```mermaid
flowchart TD
    ExtentTree["Extent TreeBTRFS_EXTENT_TREE_OBJECTID"]
    ExtentItem["EXTENT_ITEMextent allocation record"]
    BackrefItem["Backref itemsEXTENT_DATA_REFSHARED_BLOCK_REF"]
    PhysAddr["Physical extentbytenr, num_bytes"]
    RefCount["Reference countIncremented by snapshots"]
    Flags["FlagsDATA, METADATA, TREE_BLOCK"]
    DataRef["Data backrefroot, objectid, offset"]
    SharedRef["Shared backrefparent tree block"]

    ExtentTree --> ExtentItem
    ExtentItem --> BackrefItem
    ExtentItem --> PhysAddr
    ExtentItem --> RefCount
    ExtentItem --> Flags
    BackrefItem --> DataRef
    BackrefItem --> SharedRef
```
**Extent Allocation Flow:**

The function `btrfs_reserve_extent()` [fs/btrfs/extent-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c) allocates space:

1.  Select appropriate block group based on data/metadata type and RAID profile
2.  Search free space in block group using either free space cache or free space tree
3.  Reserve the extent in memory structures
4.  Insert extent item into extent tree during transaction commit

**File Extent Items:**

File data extents are tracked with `EXTENT_DATA` items in the FS tree:

```
File Extent Item
├── disk_bytenr - Physical location (or 0 for holes/inline)
├── disk_num_bytes - Size of extent on disk
├── offset - Offset within disk extent (for shared extents)
├── num_bytes - Logical size in file
├── compression - Compression type (NONE, ZLIB, LZO, ZSTD)
└── encryption - Encryption type (currently unused)
```
Sources: [fs/btrfs/extent-tree.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c#L1-L100) [fs/btrfs/file.c137-248](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/file.c#L137-L248)

### Delayed References

Btrfs uses delayed references to batch extent tree updates for efficiency:

```mermaid
flowchart TD
    Operation["File operationwrite, snapshot, etc."]
    AddDelayedRef["btrfs_add_delayed_ref()delayed-ref.c"]
    DelayedRefHead["delayed_ref_headPer-extent head node"]
    DelayedRefNode["delayed_ref_nodeIndividual ref update"]
    RunDelayed["__btrfs_run_delayed_refs()Process queued updates"]
    UpdateExtent["Update extent tree_btrfs_free_extent()alloc_reserved*()"]
    Transaction["Transaction commit"]

    Operation --> AddDelayedRef
    AddDelayedRef --> DelayedRefHead
    DelayedRefHead --> DelayedRefNode
    Transaction --> RunDelayed
    RunDelayed --> UpdateExtent
```
Delayed references accumulate reference count changes (+1 for new refs, -1 for deletions) and are applied in batches during transaction commit, reducing B-tree modifications.

Sources: [fs/btrfs/delayed-ref.c1-50](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/delayed-ref.c#L1-L50) [fs/btrfs/extent-tree.c48-61](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c#L48-L61)

## Snapshots and Subvolumes

Snapshots and subvolumes are core features enabled by COW. Each subvolume is an independent B-tree namespace with its own root.

### Subvolume Structure

```mermaid
flowchart TD
    RootTree["Root TreeBTRFS_ROOT_TREE_OBJECTID"]
    RootItem1["Root Itemsubvolume 1"]
    RootItem2["Root Itemsubvolume 2"]
    RootItem3["Root Itemsnapshot of subvol 1"]
    FSTree1["FS TreeFiles and dirs"]
    FSTree2["FS TreeFiles and dirs"]
    FSTree3["FS TreeShared with subvol 1"]
    SharedExtent["Shared ExtentsReference counted"]

    RootTree --> RootItem1
    RootTree --> RootItem2
    RootTree --> RootItem3
    RootItem1 --> FSTree1
    RootItem2 --> FSTree2
    RootItem3 --> FSTree3
    FSTree1 --> SharedExtent
    FSTree3 --> SharedExtent
```
**Snapshot Creation:**

Creating a snapshot involves:

1.  COW the root tree block of source subvolume
2.  Create new root item pointing to the COW'd tree
3.  Increment reference counts on all shared extents (via delayed refs)
4.  Both subvolumes now share the same tree blocks and extents

All subsequent modifications use COW, so the snapshot remains unchanged while the original subvolume evolves.

Sources: [fs/btrfs/ioctl.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ioctl.c#L1-L100) [fs/btrfs/ctree.c177-186](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ctree.c#L177-L186)

### Reference Counting

Btrfs maintains reference counts for extents in the extent tree. When an extent is referenced by multiple snapshots, its reference count reflects this:

-   **Simple reference**: Single owner, ref\_count = 1
-   **Shared reference**: Multiple owners (snapshots), ref\_count > 1
-   **Backref walking**: [fs/btrfs/backref.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/backref.c) provides functions to find all references to an extent

## RAID Support

Btrfs implements software RAID with support for RAID 0, 1, 10, 5, and 6. The RAID layer is integrated into the volume manager.

### RAID Architecture

```mermaid
flowchart TD
    FileWrite["File write operation"]
    BioSubmit["btrfs_submit_bbio()bio.c"]
    MapBio["btrfs_map_bio()volumes.cMap logical to physical"]
    ChunkMap["Chunk Mappingbtrfs_chunk_map"]
    Profile["RAID ProfileRAID0/1/10/5/6"]
    RAID0["RAID 0Stripe across devices"]
    RAID1["RAID 1Mirror to N devices"]
    RAID56["RAID 5/6Parity stripes"]
    RBIO["btrfs_raid_bioraid56.cRAID 5/6 I/O structure"]
    ParityCalc["Parity calculationasync workers"]
    DeviceIO["Device I/Oto physical devices"]

    FileWrite --> BioSubmit
    BioSubmit --> MapBio
    MapBio --> ChunkMap
    ChunkMap --> Profile
    Profile --> RAID0
    Profile --> RAID1
    Profile --> RAID56
    RAID56 --> RBIO
    RBIO --> ParityCalc
    RAID0 --> DeviceIO
    RAID1 --> DeviceIO
    ParityCalc --> DeviceIO
```
**RAID Profiles:**

| Profile | Redundancy | Min Devices | Description |
| --- | --- | --- | --- |
| RAID0 | None | 2 | Striping for performance |
| RAID1 | 1 copy | 2 | Mirroring (2-way or N-way) |
| RAID10 | 1 copy | 4 | Striped mirrors |
| RAID5 | 1 parity | 3 | Single parity stripe |
| RAID6 | 2 parity | 4 | Double parity stripe |

RAID 5/6 implementation is in [fs/btrfs/raid56.c1-150](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/raid56.c#L1-L150) with support for:

-   Parity calculation using CPU or async workers
-   Read-modify-write for partial stripe updates
-   Reconstruction on device failure
-   Scrubbing to verify parity correctness

Sources: [fs/btrfs/volumes.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/volumes.c#L1-L100) [fs/btrfs/raid56.c1-150](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/raid56.c#L1-L150)

## Compression

Btrfs supports transparent compression of file data with multiple algorithms. Compression is applied per extent during writeback.

### Compression Flow

```mermaid
flowchart TD
    Write["Writeback beginscompress_file_range()fs/btrfs/inode.c:879-1074async_chunk work"]
    NeedCompress["inode_need_compress()fs/btrfs/inode.c:808-835Check mount opts, props, flags"]
    CompressType["Select compressionBTRFS_COMPRESS_ZLIB=1BTRFS_COMPRESS_LZO=2BTRFS_COMPRESS_ZSTD=3From inode->defrag_compress or fs_info"]
    CompressLevel["Compression Levelfs_info->compress_levelinode->defrag_compress_level"]
    CompressFolios["btrfs_compress_folios()fs/btrfs/compression.cDispatch to zlib_compress_folios()or lzo_compress_folios()or zstd_compress_folios()"]
    CheckRatio["Check compression ratioif (total_compressed + blocksize > total_in)goto mark_incompressible"]
    Inline["Try inline extentcow_file_range_inline()fs/btrfs/inode.c:706-753can_cow_file_range_inline()"]
    Regular["add_async_extent()Create compressed extentSet compress_type"]
    Fallback["mark_incompressible:Set BTRFS_INODE_NOCOMPRESSadd_async_extent(NONE)"]
    WriteExtent["submit_one_async_extent()fs/btrfs/inode.c:1121-1231btrfs_alloc_ordered_extent()Set BTRFS_ORDERED_COMPRESSED"]

    Write --> NeedCompress
    NeedCompress --> CompressType
    CompressType --> CompressLevel
    CompressLevel --> CompressFolios
    CompressFolios --> CheckRatio
    CheckRatio --> Inline
    CheckRatio --> Regular
    CheckRatio --> Fallback
    Inline --> WriteExtent
    Regular --> WriteExtent
```
**Compression Algorithms:**

Btrfs supports multiple compression algorithms [fs/btrfs/compression.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/compression.c#L1-L100):

-   **ZLIB** (`BTRFS_COMPRESS_ZLIB`): Default, balanced compression ratio using deflate
-   **LZO** (`BTRFS_COMPRESS_LZO`): Fast compression with lower ratio, suitable for CPU-constrained systems
-   **ZSTD** (`BTRFS_COMPRESS_ZSTD`): Modern algorithm with configurable levels (1-15), best balance of speed and ratio

Compression is controlled by:

1.  Mount options: `compress=zlib`, `compress=lzo`, `compress=zstd:level`
2.  Per-file properties: `btrfs.compression` extended attribute
3.  Inode flags: `BTRFS_INODE_COMPRESS`, `BTRFS_INODE_NOCOMPRESS` [fs/btrfs/btrfs\_inode.h](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/btrfs_inode.h)
4.  Defrag settings: `inode->defrag_compress` and `inode->defrag_compress_level`

**Decompression on Read:**

Compressed extents are decompressed during read via `btrfs_submit_compressed_read()` [fs/btrfs/compression.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/compression.c) which:

1.  Allocates decompression pages
2.  Submits read bio for compressed data
3.  Queues async decompression work on completion
4.  Copies decompressed data to page cache

Sources: [fs/btrfs/inode.c808-835](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L808-L835) [fs/btrfs/inode.c879-1074](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L879-L1074) [fs/btrfs/inode.c706-753](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L706-L753) [fs/btrfs/inode.c1121-1231](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L1121-L1231) [fs/btrfs/compression.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/compression.c#L1-L100)

## Data Integrity and Checksumming

Btrfs checksums all data and metadata to detect corruption. Checksums are stored separately from data in the checksum tree.

### Checksumming Architecture

```mermaid
flowchart TD
    Write["Write I/O"]
    CalcCsum["Calculate checksumbtrfs_csum_data()"]
    StoreCsum["Store in csum treeBTRFS_CSUM_ITEM_KEY"]
    CsumTree["Checksum TreePer-filesystem global tree"]
    CsumItem["Checksum ItemCovers 1+ sectors"]
    Read["Read I/O"]
    LookupCsum["btrfs_lookup_bio_sums()file-item.c"]
    VerifyCsum["Verify checksumin end_bbio_data_read()"]
    Match["Checksum matches"]
    Mismatch["Checksum mismatch"]
    ReturnData["Return data to user"]
    TryRepair["Try alternate mirrorbtrfs_repair_io_failure()"]
    PrintError["btrfs_print_data_csum_error()inode.c:310-339"]

    Write --> CalcCsum
    CalcCsum --> StoreCsum
    StoreCsum --> CsumTree
    CsumTree --> CsumItem
    Read --> LookupCsum
    LookupCsum --> VerifyCsum
    VerifyCsum --> Match
    VerifyCsum --> Mismatch
    Match --> ReturnData
    Mismatch --> TryRepair
    TryRepair --> PrintError
```
**Checksum Types:**

Btrfs supports multiple checksum algorithms configured at filesystem creation:

-   CRC32C (default)
-   XXHASH
-   SHA256
-   BLAKE2

**Metadata Checksumming:**

Tree blocks are checksummed in `btree_csum_one_bio()` [fs/btrfs/disk-io.c267-338](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L267-L338) before write. On read, `btrfs_validate_extent_buffer()` [fs/btrfs/disk-io.c366-476](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L366-L476) verifies the checksum.

**Error Detection and Repair:**

When a checksum mismatch is detected:

1.  Try reading from alternate mirror (RAID1/10)
2.  If successful, repair the corrupted copy via `btrfs_repair_io_failure()` [fs/btrfs/disk-io.c182-214](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L182-L214)
3.  If all copies are corrupt, return error to user

Sources: [fs/btrfs/disk-io.c74-112](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L74-L112) [fs/btrfs/disk-io.c267-338](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/disk-io.c#L267-L338) [fs/btrfs/inode.c310-339](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L310-L339) [fs/btrfs/extent\_io.c574-622](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L574-L622)

## Tree Logging for Fast Fsync

Btrfs uses a per-subvolume log tree to optimize `fsync()` operations, avoiding full transaction commits for most cases.

### Tree Log Architecture

```mermaid
flowchart TD
    Fsync["fsync(fd)"]
    LogInode["btrfs_log_inode()tree-log.c:228-231"]
    StartLog["start_log_trans()tree-log.c:287-368Create/join log tree"]
    LogTree["Log TreePer-subvolume temporary tree"]
    LogItems["Copy modified itemsto log tree"]
    LogExtents["Log file extent items"]
    LogInodeItem["Log inode item"]
    LogDirItems["Log directory items"]
    SyncLog["btrfs_sync_log()Write log tree to disk"]
    LogRoot["Log Root TreeGlobal tree tracking all log trees"]
    Commit["Wait for log writeFast compared to full commit"]

    Fsync --> LogInode
    LogInode --> StartLog
    StartLog --> LogTree
    LogInode --> LogItems
    LogItems --> LogTree
    LogItems --> LogExtents
    LogItems --> LogInodeItem
    LogItems --> LogDirItems
    LogTree --> SyncLog
    SyncLog --> LogRoot
    SyncLog --> Commit
```
**Log Replay on Mount:**

After a crash, `btrfs_recover_log_trees()` [fs/btrfs/tree-log.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c) replays logged operations:

1.  **PIN stage** [fs/btrfs/tree-log.c99-104](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c#L99-L104) - Pin logged extents to prevent reuse
2.  **REPLAY\_INODES stage** [fs/btrfs/tree-log.c101](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c#L101-L101) - Recreate inodes
3.  **REPLAY\_DIR\_INDEX stage** [fs/btrfs/tree-log.c102](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c#L102-L102) - Recreate directory entries
4.  **REPLAY\_ALL stage** [fs/btrfs/tree-log.c103](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c#L103-L103) - Apply all remaining changes

The log tree is designed to be minimal - only logging what's necessary for crash consistency, making fsync significantly faster than committing the entire filesystem transaction.

Sources: [fs/btrfs/tree-log.c1-258](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c#L1-L258) [fs/btrfs/tree-log.c287-368](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/tree-log.c#L287-L368)

## Multi-Device and Volume Management

Btrfs includes integrated volume management, allowing multiple devices to be combined into a single filesystem with various RAID profiles.

### Volume Management Structure

```mermaid
flowchart TD
    FSInfo["btrfs_fs_infoPer-filesystem state"]
    FSDevices["btrfs_fs_devicesvolumes.cDevice set"]
    Device1["btrfs_deviceIndividual device"]
    Device2["btrfs_device"]
    Device3["btrfs_device"]
    ChunkTree["Chunk TreeLogical to physical mapping"]
    ChunkItem["Chunk ItemLogical range mapping"]
    StripeInfo["Stripes[]Physical device + offset"]
    DevExtent["Device Extent TreePhysical space allocation"]

    FSInfo --> FSDevices
    FSDevices --> Device1
    FSDevices --> Device2
    FSDevices --> Device3
    ChunkTree --> ChunkItem
    ChunkItem --> StripeInfo
    StripeInfo --> Device1
    StripeInfo --> Device2
    StripeInfo --> Device3
    Device1 --> DevExtent
    Device2 --> DevExtent
    Device3 --> DevExtent
```
**Chunk Allocation:**

Chunks are large contiguous allocations (typically 1GB for data, 256MB for metadata) that map logical addresses to physical device locations:

```
btrfs_chunk_map
├── start - Logical address
├── length - Chunk size
├── type - DATA, METADATA, or SYSTEM + RAID profile
├── num_stripes - Number of stripes in chunk
└── stripes[] - Array of (device, offset) pairs
```
The function `btrfs_map_block()` [fs/btrfs/volumes.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/volumes.c) converts logical addresses to physical device locations using chunk mappings.

**Device Operations:**

-   **Add device**: Extends filesystem capacity
-   **Remove device**: Relocates data and rebalances
-   **Replace device**: For failing drive replacement
-   **Resize**: Grow or shrink filesystem on device

Sources: [fs/btrfs/volumes.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/volumes.c#L1-L100) [fs/btrfs/volumes.c37-96](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/volumes.c#L37-L96)

## Zoned Device Support

Btrfs supports zoned block devices (ZBC/ZNS) which have sequential write constraints. The zoned mode ensures all writes are sequential within zones.

### Zoned Device Architecture

```mermaid
flowchart TD
    ZonedFS["Zoned Btrfs Filesystembtrfs_is_zoned()"]
    DeviceInfo["btrfs_zoned_device_infozoned.c:356-605"]
    ZoneSize["zone_sizeFixed zone size"]
    ZoneBitmap["Zone bitmapsseq_zones, empty_zones, active_zones"]
    MaxActive["max_active_zonesDevice limit"]
    BlockGroup["Block GroupAligned to zone boundaries"]
    SeqWrite["Sequential WriteEnforced by zone WP"]
    ZoneFinish["Zone Finishdo_zone_finish()zoned.c:71"]
    Superblock["Superblock ZonesSpecial zone pairszoned.c:30-45"]
    SBZone0["SB Zone 0 (primary)"]
    SBZone1["SB Zone 1 (first copy)"]
    SBZone2["SB Zone 2 (second copy)"]

    ZonedFS --> DeviceInfo
    DeviceInfo --> ZoneSize
    DeviceInfo --> ZoneBitmap
    DeviceInfo --> MaxActive
    ZonedFS --> BlockGroup
    BlockGroup --> SeqWrite
    BlockGroup --> ZoneFinish
    ZonedFS --> Superblock
    Superblock --> SBZone0
    Superblock --> SBZone1
    Superblock --> SBZone2
```
**Key Zoned Constraints:**

1.  **Sequential Writes**: All writes within a zone must be sequential, enforced by zone write pointers
2.  **Zone Alignment**: Block groups align to zone boundaries
3.  **Active Zone Limits**: Devices limit number of concurrently active zones
4.  **No In-Place Updates**: COW is mandatory (NODATACOW not supported)

**Zoned Operations:**

-   **Zone allocation**: Track zone write pointers and allocate from empty/active zones
-   **Zone finishing**: Close zones when block group is full [fs/btrfs/zoned.c71](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/zoned.c#L71-L71)
-   **Reset zones**: Reset write pointer when freeing block group
-   **Superblock zones**: Use zone pairs for superblock with log-structured updates [fs/btrfs/zoned.c88-161](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/zoned.c#L88-L161)

Sources: [fs/btrfs/zoned.c1-70](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/zoned.c#L1-L70) [fs/btrfs/zoned.c355-605](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/zoned.c#L355-L605) [fs/btrfs/zoned.c88-161](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/zoned.c#L88-L161)

## I/O Path

### Read Path

```mermaid
flowchart TD
    ReadSyscall["read() system call"]
    VFSRead["VFS generic_file_read_iter()mm/filemap.c"]
    PageCache["Page Cache Lookupfilemap_get_read_batch()Find folios"]
    Hit["Cache HitCopy to user bufferUpdate atime"]
    Miss["Cache MissTrigger btrfs_readahead()fs/btrfs/file.c"]
    DoReadpage["do_readpage()Submit read biosFor each folio"]
    LookupExtent["btrfs_get_extent()Find extent mappingSearch EXTENT_DATA items"]
    CreateEM["create_io_em()struct extent_mapCache in em_tree"]
    FileExtent["struct btrfs_file_extent_itemdisk_bytenr, offsetnum_bytes, compression"]
    CheckType["Check extent typeINLINE, REG, PREALLOC"]
    Compressed["compression != NONE?ZLIB/LZO/ZSTD"]
    CompressRead["btrfs_submit_compressed_read()fs/btrfs/compression.cAlloc compressed_bioRead + decompress async"]
    RegularRead["submit_extent_folio()fs/btrfs/extent_io.c:786Add to bio_ctrl"]
    BioSubmit["submit_one_bio()fs/btrfs/extent_io.c:174-220btrfs_submit_bbio()"]
    MapBio["btrfs_map_bio()fs/btrfs/volumes.cLogical to physical mapping"]
    EndBio["end_bbio_data_read()fs/btrfs/extent_io.c:574-622I/O completion handler"]
    LookupCsum["btrfs_lookup_bio_sums()fs/btrfs/file-item.cGet checksums from csum tree"]
    VerifyCsum["Verify checksumCompare calculated vs stored"]
    CsumOK["Checksum OKbtrfs_folio_set_uptodate()end_folio_read()"]
    CsumFail["Checksum mismatchbtrfs_print_data_csum_error()Try btrfs_repair_io_failure()"]

    ReadSyscall --> VFSRead
    VFSRead --> PageCache
    PageCache --> Hit
    PageCache --> Miss
    Miss --> DoReadpage
    DoReadpage --> LookupExtent
    LookupExtent --> CreateEM
    CreateEM --> FileExtent
    FileExtent --> CheckType
    CheckType --> Compressed
    Compressed --> CompressRead
    Compressed --> RegularRead
    CompressRead --> BioSubmit
    RegularRead --> BioSubmit
    BioSubmit --> MapBio
    MapBio --> LookupCsum
    LookupCsum --> EndBio
    EndBio --> VerifyCsum
    VerifyCsum --> CsumOK
    VerifyCsum --> CsumFail
```
Sources: [fs/btrfs/extent\_io.c574-622](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L574-L622) [fs/btrfs/extent\_io.c786](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L786-L786) [fs/btrfs/extent\_io.c174-220](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L174-L220) [fs/btrfs/compression.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/compression.c#L1-L100) [fs/btrfs/file-item.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/file-item.c) [fs/btrfs/volumes.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/volumes.c)

### Write Path

```mermaid
flowchart TD
    WriteSyscall["write() system call"]
    VFSWrite["VFS __generic_file_write_iter()mm/filemap.c"]
    PrepFolio["prepare_one_folio()Allocate/find folio"]
    CopyToCache["copy_folio_from_iter_atomic()mm/filemap.cCopy user data to page cache"]
    DirtyFolio["btrfs_dirty_folio()fs/btrfs/file.c:70-120Mark folio dirty in Btrfs"]
    Delalloc["btrfs_set_extent_delalloc()Set EXTENT_DELALLOC bitin inode->io_tree"]
    ReserveSpace["btrfs_delalloc_reserve_space()Reserve metadata + data spaceUpdate space_info"]
    Writeback["Writeback triggeredextent_writepage()fs/btrfs/extent_io.c"]
    FindRange["find_lock_delalloc_range()fs/btrfs/extent_io.c:369-466Lock contiguous delalloc"]
    Compress["compress_file_range()fs/btrfs/inode.c:879-1074If inode_need_compress()"]
    NoCOW["Check BTRFS_INODE_NODATACOWcan_cow_file_range_inline()"]
    COW["run_delalloc_cow()fs/btrfs/inode.c:123-126Standard COW path"]
    AllocExtent["btrfs_reserve_extent()fs/btrfs/extent-tree.cfind_free_extent()Allocate from block group"]
    CreateEM["btrfs_create_io_em()Create struct extent_mapAdd to inode->extent_tree"]
    CreateOrdered["btrfs_alloc_ordered_extent()fs/btrfs/ordered-data.cstruct btrfs_ordered_extentAdd to inode->ordered_tree"]
    SubmitBio["submit_one_bio()fs/btrfs/extent_io.c:174-220bio_ctrl->bbio"]
    MapBio["btrfs_map_bio()fs/btrfs/volumes.cMap logical to physical"]
    BioEnd["end_bbio_data_write()fs/btrfs/extent_io.c:518-550I/O completion"]
    FinishOrdered["btrfs_finish_ordered_extent()fs/btrfs/ordered-data.cInsert EXTENT_DATA itemAdd checksums to csum treeUpdate extent refs"]

    WriteSyscall --> VFSWrite
    VFSWrite --> PrepFolio
    PrepFolio --> CopyToCache
    CopyToCache --> DirtyFolio
    DirtyFolio --> Delalloc
    DirtyFolio --> ReserveSpace
    Delalloc --> Writeback
    Writeback --> FindRange
    FindRange --> Compress
    FindRange --> NoCOW
    FindRange --> COW
    Compress --> AllocExtent
    COW --> AllocExtent
    AllocExtent --> CreateEM
    CreateEM --> CreateOrdered
    CreateOrdered --> SubmitBio
    SubmitBio --> MapBio
    MapBio --> BioEnd
    BioEnd --> FinishOrdered
```
The write path uses **delayed allocation (delalloc)** to batch extent allocation and allow for better space packing. This is tracked via the `EXTENT_DELALLOC` bit in `inode->io_tree` [fs/btrfs/extent\_io.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c)

**Ordered extents** (`struct btrfs_ordered_extent`) ensure that data reaches disk before metadata updates, maintaining crash consistency. The ordered extent tracks:

-   File offset range
-   Disk bytenr and num\_bytes
-   Flags: `BTRFS_ORDERED_COMPRESSED`, `BTRFS_ORDERED_PREALLOC`, etc.
-   Completion state for synchronization

Sources: [fs/btrfs/file.c70-120](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/file.c#L70-L120) [fs/btrfs/inode.c123-126](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L123-L126) [fs/btrfs/inode.c879-1074](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/inode.c#L879-L1074) [fs/btrfs/extent\_io.c369-466](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L369-L466) [fs/btrfs/extent\_io.c174-220](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L174-L220) [fs/btrfs/extent\_io.c518-550](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent_io.c#L518-L550) [fs/btrfs/ordered-data.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/ordered-data.c)

## Transaction Management

All modifications in Btrfs occur within transactions. Transactions group related changes and provide atomicity.

### Transaction Lifecycle

```mermaid
flowchart TD
    Start["btrfs_start_transaction()transaction.c"]
    Running["Transaction RunningTRANS_STATE_RUNNING"]
    Modify["Modify B-treesCOW operationsDelayed refs"]
    End["btrfs_end_transaction()Release transaction handle"]
    Commit["btrfs_commit_transaction()Triggered by sync/timer"]
    Flush["Flush delallocRun delayed refs"]
    CreateSnapshot["Create transaction snapshot"]
    WriteTree["Write dirty tree blocks"]
    UpdateSuper["Update superblock"]
    Complete["Transaction CompleteTRANS_STATE_COMPLETED"]

    Start --> Running
    Running --> Modify
    Modify --> End
    End --> Commit
    Commit --> Flush
    Flush --> CreateSnapshot
    CreateSnapshot --> WriteTree
    WriteTree --> UpdateSuper
    UpdateSuper --> Complete
```
**Transaction Handle:**

```
struct btrfs_trans_handle
├── transid - Transaction ID
├── blocks_reserved - Reserved metadata space
├── block_rsv - Block reservation tracking
├── fs_info - Filesystem info
└── type - Transaction type flags
```
Transactions are committed:

-   Explicitly via `sync()` or `fsync()`
-   Periodically (default 30 seconds)
-   When metadata space is low
-   When too many delayed refs accumulate

Sources: [fs/btrfs/transaction.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/transaction.c#L1-L100)

## Block Groups and Space Management

Btrfs divides device space into block groups, each with a specific type (DATA, METADATA, SYSTEM) and RAID profile.

### Block Group Structure

```mermaid
flowchart TD
    SpaceInfo["btrfs_space_infoPer-type space accounting"]
    DataSpace["DATA space_info"]
    MetaSpace["METADATA space_info"]
    SysSpace["SYSTEM space_info"]
    BlockGroup1["btrfs_block_groupblock-group.c"]
    BlockGroup2["btrfs_block_group"]
    BlockGroup3["btrfs_block_group"]
    BGItem["Block Group ItemIn extent tree"]
    FreeSpace["Free Space Cachev1 or free space tree v2"]
    Zone["Zone infofor zoned devices"]
    Allocator["Extent Allocatorfind_free_extent()"]
    Allocate["Allocate extentfrom block group"]

    SpaceInfo --> DataSpace
    SpaceInfo --> MetaSpace
    SpaceInfo --> SysSpace
    DataSpace --> BlockGroup1
    DataSpace --> BlockGroup2
    MetaSpace --> BlockGroup3
    BlockGroup1 --> BGItem
    BlockGroup1 --> FreeSpace
    BlockGroup1 --> Zone
    FreeSpace --> Allocator
    Allocator --> Allocate
```
**Block Group Types:**

-   **DATA**: File data extents
-   **METADATA**: B-tree nodes, inode items, etc.
-   **SYSTEM**: Chunk tree and device tree (critical metadata)

Each block group can have a different RAID profile, e.g., RAID1 for metadata and RAID0 for data.

**Space Allocation:**

The allocator [fs/btrfs/extent-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c) selects block groups based on:

1.  Type (data vs metadata)
2.  Available free space
3.  RAID profile
4.  Locality (prefer block groups with recent allocations)

Sources: [fs/btrfs/block-group.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/block-group.c#L1-L100) [fs/btrfs/extent-tree.c](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/extent-tree.c)

## Quota Groups (Qgroups)

Qgroups provide hierarchical quota management for subvolumes and snapshots.

### Qgroup Hierarchy

```mermaid
flowchart TD
    QTree["Quota TreeBTRFS_QUOTA_TREE_OBJECTID"]
    Qgroup0["Qgroup 0/subvol_idPer-subvolume qgroup"]
    Qgroup1["Qgroup 1/group_idUser-defined group"]
    QgroupInfo["btrfs_qgroupqgroup.c"]
    Accounting["Space Accountingreferenced, exclusive"]
    Limit["Quota Limitsmax_referenced, max_exclusive"]
    Relations["Parent-child relations"]
    Track["Track extent ownershipUpdate on COW"]

    QTree --> Qgroup0
    QTree --> Qgroup1
    Qgroup0 --> QgroupInfo
    QgroupInfo --> Accounting
    QgroupInfo --> Limit
    QgroupInfo --> Relations
    Accounting --> Track
```
**Qgroup Accounting:**

-   **Referenced**: Total space referenced by this qgroup (may be shared)
-   **Exclusive**: Space exclusively owned by this qgroup
-   **Rfer\_cmpr**: Referenced compressed space
-   **Excl\_cmpr**: Exclusive compressed space

Qgroups are updated when:

-   Extents are allocated or freed
-   Snapshots are created (affects exclusivity)
-   Extent ownership changes via COW

Sources: [fs/btrfs/qgroup.c1-100](https://github.com/torvalds/linux/blob/fcb70a56/fs/btrfs/qgroup.c#L1-L100)

## Summary

Btrfs is a comprehensive copy-on-write filesystem with integrated volume management. Its key architectural components include:

1.  **B-tree storage engine** (`ctree.c`) managing multiple tree namespaces
2.  **Copy-on-write at all levels** enabling snapshots and crash recovery
3.  **Extent-based allocation** with delayed reference updates for efficiency
4.  **Integrated RAID** supporting multiple redundancy profiles
5.  **Compression and checksumming** for space efficiency and data integrity
6.  **Tree logging** for fast fsync operations
7.  **Multi-device support** with flexible chunk allocation
8.  **Zoned device support** for sequential-write storage
9.  **Hierarchical quota groups** for space accounting

The filesystem balances performance, features, and data integrity through careful design of its COW semantics, delayed operations, and transaction management.
