# Redis Cluster

Relevant source files

-   [src/cluster.c](https://github.com/redis/redis/blob/8ad54215/src/cluster.c)
-   [src/cluster.h](https://github.com/redis/redis/blob/8ad54215/src/cluster.h)
-   [src/cluster\_legacy.c](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.c)
-   [src/cluster\_legacy.h](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h)
-   [tests/support/cluster\_util.tcl](https://github.com/redis/redis/blob/8ad54215/tests/support/cluster_util.tcl)
-   [tests/unit/cluster/hostnames.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/cluster/hostnames.tcl)
-   [tests/unit/cluster/human-announced-nodename.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/cluster/human-announced-nodename.tcl)

Redis Cluster is Redis's built-in solution for horizontal scaling and high availability through automatic data sharding and replication. It distributes data across multiple Redis instances using a hash slot mechanism and provides automatic failover capabilities when nodes become unavailable.

For information about Redis replication between master and replica nodes, see [Replication](/redis/redis/4.1-eviction-and-expiration-policies). For high availability monitoring and failover coordination, see [Redis Sentinel](/redis/redis/4.2-memory-allocators-and-build-system).

## Architecture Overview

Redis Cluster implements a distributed hash table where data is automatically partitioned across multiple Redis nodes. The cluster uses a hash slot approach with 16,384 slots total, where each master node is responsible for a subset of these slots.

### Cluster Architecture Diagram

```mermaid
flowchart TD
    App1["Application 1"]
    App2["Application 2"]
    App3["Application 3"]
    Master1["redis-serverMaster Node 1cluster.c"]
    Replica1["redis-serverReplica Node 1"]
    Master2["redis-serverMaster Node 2cluster.c"]
    Replica2["redis-serverReplica Node 2"]
    Master3["redis-serverMaster Node 3cluster.c"]
    Replica3["redis-serverReplica Node 3"]
    Bus["Gossip ProtocolPort + 10000clusterMsg"]

    Master1 --> Replica1
    Master2 --> Replica2
    Master3 --> Replica3
    Master1 --> Bus
    Master2 --> Bus
    Master3 --> Bus
    Replica1 --> Bus
    Replica2 --> Bus
    Replica3 --> Bus
    App1 --> Master1
    App2 --> Master2
    App3 --> Master3
    App1 --> Master2
    App1 --> Master3
    App2 --> Master1
    App2 --> Master3
    App3 --> Master1
    App3 --> Master2
```
Sources: [src/cluster.h22-27](https://github.com/redis/redis/blob/8ad54215/src/cluster.h#L22-L27) [src/cluster\_legacy.h341-390](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L341-L390)

## Hash Slot Distribution

The cluster partitions the key space using a hash slot mechanism. Each key is mapped to one of 16,384 hash slots using CRC16 hashing.

### Key Hashing Implementation

```mermaid
flowchart TD
    TagKey["Key with Tag'user:{1000}:profile'"]
    TagHash["CRC16 of'{1000}' only"]
    SameSlot["Same Slotas 'user:{1000}:data'"]
    Key["Redis Key'user:1000'"]
    Hash["keyHashSlot()CRC16 Algorithm"]
    Slot["Hash Slot0-16383"]
    Node["Responsible NodeclusterNode"]

    Key --> Hash
    Hash --> Slot
    Slot --> Node
    TagKey --> TagHash
    TagHash --> SameSlot
```
The `keyHashSlot` function implements the core hashing logic:

Sources: [src/cluster.h57-76](https://github.com/redis/redis/blob/8ad54215/src/cluster.h#L57-L76) [src/cluster.c34-59](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L34-L59)

### Hash Slot Assignment

Each master node is assigned a range of hash slots during cluster setup. The slot assignment is stored in the `clusterState.slots` array and propagated throughout the cluster via gossip protocol.

| Component | Purpose | Implementation |
| --- | --- | --- |
| `CLUSTER_SLOTS` | Total number of slots (16384) | [src/cluster.h23](https://github.com/redis/redis/blob/8ad54215/src/cluster.h#L23-L23) |
| `keyHashSlot()` | Maps keys to slots using CRC16 | [src/cluster.h57-76](https://github.com/redis/redis/blob/8ad54215/src/cluster.h#L57-L76) |
| `clusterState.slots[]` | Maps slots to responsible nodes | [src/cluster\_legacy.h351](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L351-L351) |
| `clusterNode.slots[]` | Bitmap of slots owned by node | [src/cluster\_legacy.h304](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L304-L304) |

Sources: [src/cluster.h22-24](https://github.com/redis/redis/blob/8ad54215/src/cluster.h#L22-L24) [src/cluster\_legacy.h351](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L351-L351) [src/cluster\_legacy.h304](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L304-L304)

## Core Data Structures

Redis Cluster's implementation centers around several key data structures that manage cluster state, node information, and inter-node communication.

### Cluster State Management

```mermaid
flowchart TD
    ClusterState["clusterStateserver.cluster"]
    Myself["myselfclusterNode*"]
    Nodes["nodesdict* (name -> clusterNode)"]
    Shards["shardsdict* (shard_id -> list)"]
    Slots["slots[CLUSTER_SLOTS]clusterNode* array"]
    Epoch["currentEpochConfiguration version"]
    State["stateCLUSTER_OK/CLUSTER_FAIL"]
    Node["clusterNode"]
    Name["name[CLUSTER_NAMELEN]40-char hex ID"]
    ShardId["shard_id[CLUSTER_NAMELEN]Shard identifier"]
    Flags["flagsMASTER/SLAVE/FAIL/etc"]
    NodeSlots["slots[CLUSTER_SLOTS/8]Owned slot bitmap"]
    Link["linkclusterLink* connection"]
    Slaves["slavesclusterNode** array"]
    ClusterLink["clusterLink"]
    Conn["connconnection*"]
    SendQueue["send_msg_queuelist* of messages"]
    RcvBuf["rcvbufReception buffer"]

    ClusterState --> Myself
    ClusterState --> Nodes
    ClusterState --> Shards
    ClusterState --> Slots
    ClusterState --> Epoch
    ClusterState --> State
    Node --> Name
    Node --> ShardId
    Node --> Flags
    Node --> NodeSlots
    Node --> Link
    Node --> Slaves
    ClusterLink --> Conn
    ClusterLink --> SendQueue
    ClusterLink --> RcvBuf
    Myself --> Node
    Nodes --> Node
    Slots --> Node
    Node --> ClusterLink
```
Sources: [src/cluster\_legacy.h341-390](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L341-L390) [src/cluster\_legacy.h298-332](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L298-L332) [src/cluster\_legacy.h44-55](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L44-L55)

### Message Protocol Structure

The cluster bus protocol uses the `clusterMsg` structure for all inter-node communication:

| Field | Type | Purpose |
| --- | --- | --- |
| `sig[4]` | char | Protocol signature "RCmb" |
| `totlen` | uint32\_t | Total message length |
| `type` | uint16\_t | Message type (PING/PONG/MEET/FAIL) |
| `sender[CLUSTER_NAMELEN]` | char | Sending node ID |
| `myslots[CLUSTER_SLOTS/8]` | unsigned char | Sender's slot bitmap |
| `data` | union | Type-specific message data |

Sources: [src/cluster\_legacy.h230-256](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L230-L256) [src/cluster\_legacy.h94-105](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L94-L105)

## Node Discovery and Gossip Protocol

Redis Cluster uses a gossip protocol for node discovery, failure detection, and configuration propagation. Each node maintains connections to a subset of other nodes and periodically exchanges cluster state information.

### Gossip Communication Flow

> **[Mermaid sequence]**
> *(图表结构无法解析)*

### Node States and Transitions

> **[Mermaid stateDiagram]**
> *(图表结构无法解析)*

Sources: [src/cluster\_legacy.h57-78](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L57-L78) [src/cluster\_legacy.c1543-1595](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.c#L1543-L1595)

## Failover and High Availability

Redis Cluster supports both automatic and manual failover mechanisms to maintain availability when master nodes fail.

### Automatic Failover Process

```mermaid
flowchart TD
    MasterFail["Master Node FailsCLUSTER_NODE_FAIL"]
    ReplicaDetect["Replica Detects FailureclusterHandleSlaveFailover()"]
    AuthRequest["Send AUTH_REQUESTCLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST"]
    WaitVotes["Wait for VotesCLUSTERMSG_TYPE_FAILOVER_AUTH_ACK"]
    CheckMajority["Check Majorityfailover_auth_count"]
    Promote["Promote to MasterclusterSetMaster()"]
    UpdateConfig["Update ConfigurationconfigEpoch++"]
    Broadcast["Broadcast New ConfigclusterUpdateState()"]
    ClientRedirect["Redirect ClientsMOVED responses"]
    OldMasterReturns["Old Master ReturnsBecomes Replica"]

    MasterFail --> ReplicaDetect
    ReplicaDetect --> AuthRequest
    AuthRequest --> WaitVotes
    WaitVotes --> CheckMajority
    CheckMajority --> Promote
    Promote --> UpdateConfig
    UpdateConfig --> Broadcast
    Broadcast --> ClientRedirect
    ClientRedirect --> OldMasterReturns
```
### Failover State Machine

The failover process is managed by several key variables in `clusterState`:

| Variable | Purpose | Type |
| --- | --- | --- |
| `failover_auth_time` | Timing of election process | `mstime_t` |
| `failover_auth_count` | Number of received votes | `int` |
| `failover_auth_rank` | Replica's rank in election | `int` |
| `failover_auth_epoch` | Election epoch number | `uint64_t` |
| `cant_failover_reason` | Why failover is blocked | `int` |

Sources: [src/cluster\_legacy.h354-360](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L354-L360) [src/cluster\_legacy.c3956-4158](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.c#L3956-L4158)

## Slot Migration and Resharding

Redis Cluster supports live resharding through slot migration, allowing redistribution of data without downtime.

### Migration State Tracking

```mermaid
flowchart TD
    SourceSlots["slots[slot] = myself"]
    MigratingTo["migrating_slots_to[slot]= target_node"]
    ImportingFrom["importing_slots_from[slot]= source_node"]
    TargetSlots["slots[slot] = NULL(during migration)"]
    Migrate["MIGRATE commandmigrateCommand()"]
    Ask["ASK redirectionCLUSTER_REDIR_ASK"]
    Asking["ASKING commandtemporary acceptance"]

    SourceSlots --> MigratingTo
    MigratingTo --> Migrate
    Migrate --> ImportingFrom
    ImportingFrom --> TargetSlots
    Migrate --> Ask
    Ask --> Asking
```
### Migration Protocol Commands

The migration process uses several specialized commands:

| Command | Purpose | Implementation |
| --- | --- | --- |
| `MIGRATE` | Transfer keys between nodes | [src/cluster.c398-736](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L398-L736) |
| `DUMP` | Serialize key for migration | [src/cluster.c137-153](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L137-L153) |
| `RESTORE` | Deserialize key after migration | [src/cluster.c156-281](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L156-L281) |
| `ASKING` | Bypass redirection during migration | Cluster command handling |

Sources: [src/cluster.c398-736](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L398-L736) [src/cluster.c137-153](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L137-L153) [src/cluster.c156-281](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L156-L281)

## Configuration Persistence

Cluster configuration is persisted in the `nodes.conf` file, which contains node information, slot assignments, and cluster state.

### Configuration File Format

```mermaid
flowchart TD
    Header["# Configuration Format"]
    NodeLine1["node_id ip:port@cluster_port flags master_id ping_sent pong_recv config_epoch link_state slots"]
    NodeLine2["Auxiliary Fields: hostname,shard-id,tcp-port,tls-port"]
    VarsLine["vars currentEpoch lastVoteEpoch"]
    LoadConfig["clusterLoadConfig()"]
    ParseNodes["Parse Node Entries"]
    ParseAux["Parse Auxiliary FieldsauxFieldHandlers[]"]
    BuildState["Build clusterState"]
    SaveConfig["clusterSaveConfig()"]
    GenDesc["clusterGenNodesDescription()"]
    WriteFile["Atomic Write + Rename"]

    Header --> LoadConfig
    NodeLine1 --> ParseNodes
    NodeLine2 --> ParseAux
    VarsLine --> BuildState
    BuildState --> SaveConfig
    SaveConfig --> GenDesc
    GenDesc --> WriteFile
```
### Auxiliary Field Support

Modern cluster configurations support auxiliary fields for extended node metadata:

| Field | Handler Function | Purpose |
| --- | --- | --- |
| `shard-id` | `auxShardIdSetter()` | Group nodes into shards |
| `hostname` | Built-in | Human-readable endpoint |
| `tcp-port` | `auxTcpPortSetter()` | TCP client port |
| `tls-port` | `auxTlsPortSetter()` | TLS client port |

Sources: [src/cluster\_legacy.c311-665](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.c#L311-L665) [src/cluster\_legacy.c679-742](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.c#L679-L742) [src/cluster\_legacy.c197-202](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.c#L197-L202)

## Client Interaction and Redirection

Clients interact with Redis Cluster through any node, which either serves the request directly or redirects the client to the appropriate node.

### Request Routing Logic

```mermaid
flowchart TD
    ClientReq["Client RequestSET key value"]
    CalcSlot["Calculate SlotkeyHashSlot(key)"]
    CheckOwner["Check Slot OwnergetNodeByQuery()"]
    LocalServe["Serve LocallyprocessCommand()"]
    MovedRedir["MOVED RedirectionCLUSTER_REDIR_MOVED"]
    AskRedir["ASK RedirectionCLUSTER_REDIR_ASK"]
    TryAgain["TRYAGAIN ResponseCLUSTER_REDIR_UNSTABLE"]
    ClusterDown["CLUSTERDOWN ResponseCLUSTER_REDIR_DOWN_STATE"]
    NewOwner["Client connects tonew slot owner"]
    TempRedirect["Client sends ASKINGthen retries command"]

    ClientReq --> CalcSlot
    CalcSlot --> CheckOwner
    CheckOwner --> LocalServe
    CheckOwner --> MovedRedir
    CheckOwner --> AskRedir
    CheckOwner --> TryAgain
    CheckOwner --> ClusterDown
    MovedRedir --> NewOwner
    AskRedir --> TempRedirect
```
### Redirection Response Types

| Response | Meaning | Client Action |
| --- | --- | --- |
| `MOVED slot host:port` | Slot permanently moved | Update slot map, retry |
| `ASK slot host:port` | Temporary redirection during migration | Send ASKING, then command |
| `TRYAGAIN` | Cluster state unstable | Retry after delay |
| `CLUSTERDOWN` | Cluster unavailable | Handle as error |

Sources: [src/cluster.h29-37](https://github.com/redis/redis/blob/8ad54215/src/cluster.h#L29-L37) [src/cluster.h151-153](https://github.com/redis/redis/blob/8ad54215/src/cluster.h#L151-L153)

## Monitoring and Diagnostics

Redis Cluster provides extensive monitoring capabilities through various commands and metrics.

### Cluster Information Commands

```mermaid
flowchart TD
    ClusterNodes["CLUSTER NODESclusterGenNodesDescription()"]
    ClusterSlots["CLUSTER SLOTSclusterCommandSlots()"]
    ClusterShards["CLUSTER SHARDSclusterCommandShards()"]
    ClusterInfo["CLUSTER INFOgenClusterInfoString()"]
    NodeDetails["Node ID, IP, PortRole, Health, Slots"]
    SlotRanges["Slot RangesMaster/Replica mapping"]
    ShardInfo["Shard groupingsNode relationships"]
    ClusterStats["StatisticsState, Size, Epoch"]

    ClusterNodes --> NodeDetails
    ClusterSlots --> SlotRanges
    ClusterShards --> ShardInfo
    ClusterInfo --> ClusterStats
```
### Health Monitoring Metrics

The cluster tracks various statistics for monitoring:

| Metric Category | Examples | Source |
| --- | --- | --- |
| Message Statistics | Ping/Pong counts, Fail reports | `stats_bus_messages_*` |
| Node Health | PFAIL/FAIL node counts | `stats_pfail_nodes` |
| Slot Statistics | CPU usage, Network I/O per slot | `slot_stats[]` |
| Configuration | Current epoch, Cluster size | `currentEpoch`, `size` |

Sources: [src/cluster\_legacy.h375-389](https://github.com/redis/redis/blob/8ad54215/src/cluster_legacy.h#L375-L389) [src/cluster.c925-955](https://github.com/redis/redis/blob/8ad54215/src/cluster.c#L925-L955)

Redis Cluster provides a robust, scalable solution for distributing Redis data across multiple nodes while maintaining high availability through automatic failover and seamless client redirection.
