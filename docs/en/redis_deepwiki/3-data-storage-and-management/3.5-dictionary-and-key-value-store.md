# Dictionary and Key-Value Store

Relevant source files

-   [src/defrag.c](https://github.com/redis/redis/blob/8ad54215/src/defrag.c)
-   [src/dict.c](https://github.com/redis/redis/blob/8ad54215/src/dict.c)
-   [src/dict.h](https://github.com/redis/redis/blob/8ad54215/src/dict.h)
-   [src/iothread.c](https://github.com/redis/redis/blob/8ad54215/src/iothread.c)
-   [src/kvstore.c](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c)
-   [src/kvstore.h](https://github.com/redis/redis/blob/8ad54215/src/kvstore.h)
-   [tests/unit/info-keysizes.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/info-keysizes.tcl)
-   [tests/unit/info.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/info.tcl)
-   [tests/unit/memefficiency.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/memefficiency.tcl)
-   [tests/unit/networking.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/networking.tcl)
-   [tests/unit/obuf-limits.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/obuf-limits.tcl)
-   [tests/unit/shutdown.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/shutdown.tcl)

This document covers Redis's core dictionary (hash table) implementation and the key-value store layer that manages collections of dictionaries. The dictionary serves as the fundamental data structure for storing key-value pairs in Redis, while the kvstore provides higher-level abstractions for managing multiple dictionaries, particularly in cluster configurations.

The dictionary implementation includes incremental rehashing, active defragmentation, and memory-efficient entry storage optimizations. The kvstore layer extends this with statistics tracking, coordinated rehashing across multiple dictionaries, and support for both standalone and clustered Redis deployments.

## Dictionary Architecture

Redis implements hash tables through the `dict` structure defined in [src/dict.h122-137](https://github.com/redis/redis/blob/8ad54215/src/dict.h#L122-L137) The core design uses separate chaining for collision resolution with power-of-two sized hash tables that support incremental rehashing.

### Core Dictionary Structure

```mermaid
flowchart TD
    dict["dict"]
    type["dictType *type"]
    ht_table0["dictEntry **ht_table[0]"]
    ht_table1["dictEntry **ht_table[1]"]
    ht_used0["ht_used[0]"]
    ht_used1["ht_used[1]"]
    ht_size_exp0["ht_size_exp[0]"]
    ht_size_exp1["ht_size_exp[1]"]
    rehashidx["rehashidx"]
    bucket0["Bucket 0"]
    bucket1["Bucket 1"]
    bucketN["Bucket N"]
    entry1["dictEntry"]
    entry2["dictEntry"]
    entry3["dictEntry"]
    newbucket0["New Bucket 0"]
    newbucket1["New Bucket 1"]
    newbucketM["New Bucket M"]
    hashFunction["hashFunction"]
    keyCompare["keyCompare"]
    keyDup["keyDup"]
    valDup["valDup"]
    keyDestructor["keyDestructor"]
    valDestructor["valDestructor"]

    dict --> type
    dict --> ht_table0
    dict --> ht_table1
    dict --> ht_used0
    dict --> ht_used1
    dict --> ht_size_exp0
    dict --> ht_size_exp1
    dict --> rehashidx
    ht --> table0_bucket0
    ht --> table0_bucket1
    ht --> table0_bucketN
    bucket0 --> entry1
    entry1 --> entry2
    entry2 --> entry3
    ht --> table1_newbucket0
    ht --> table1_newbucket1
    ht --> table1_newbucketM
    type --> hashFunction
    type --> keyCompare
    type --> keyDup
    type --> valDup
    type --> keyDestructor
    type --> valDestructor
```
Sources: [src/dict.h122-137](https://github.com/redis/redis/blob/8ad54215/src/dict.h#L122-L137) [src/dict.c48-57](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L48-L57)

The dictionary maintains two hash tables to enable incremental rehashing. During normal operation, only `ht_table[0]` is used. When resizing is needed, `ht_table[1]` is allocated and entries are gradually moved from the old table to the new one.

### Dictionary Entry Types

Redis optimizes memory usage through different entry types using pointer bit manipulation:

```mermaid
flowchart TD
    ptr["dictEntry Pointer"]
    mask["ptr & ENTRY_PTR_MASK"]
    normal["000: Normal Entry"]
    oddkey["XX1: Odd Key Address"]
    evenkey["010: Even Key Address"]
    novalue["100: No Value Entry"]
    normalstruct["dictEntry struct- void *key- union v (val/u64/s64/d)- dictEntry *next"]
    directkey1["Direct key pointer(odd addresses)"]
    directkey2["Encoded key pointer(even addresses)"]
    novalstruct["dictEntryNoValue- void *key- dictEntry *next"]

    ptr --> mask
    mask --> normal
    mask --> oddkey
    mask --> evenkey
    mask --> novalue
    normal --> normalstruct
    oddkey --> directkey1
    evenkey --> directkey2
    novalue --> novalstruct
```
Sources: [src/dict.c128-179](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L128-L179) [src/dict.c142-150](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L142-L150)

This optimization allows dictionaries configured with `no_value=1` (like sets) to store keys directly in hash table buckets when there's only one key, avoiding allocation overhead.

## Hash Functions and Collision Resolution

### Primary Hash Function

Redis uses SipHash as the default hash function for security and distribution quality:

```mermaid
flowchart TD
    key["Input Key"]
    stored["Stored Key?"]
    storedhash["dictType->storedHashFunction"]
    normalhash["dictType->hashFunction"]
    siphash1["SipHash Implementation"]
    siphash2["SipHash Implementation"]
    seed["dict_hash_function_seed[16]"]
    result["64-bit Hash Value"]
    mask["hash & DICTHT_SIZE_MASK"]
    bucket["Target Bucket"]

    key --> stored
    stored --> storedhash
    stored --> normalhash
    storedhash --> siphash1
    normalhash --> siphash2
    siphash1 --> seed
    siphash2 --> seed
    seed --> result
    result --> mask
    mask --> bucket
```
Sources: [src/dict.c99-104](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L99-L104) [src/dict.c117-126](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L117-L126)

### Collision Resolution

Collisions are handled through separate chaining, where each bucket contains a linked list of entries:

```mermaid
flowchart TD
    bucket["Hash Bucket"]
    first["First Entrykey='user:1'hash=0x1234"]
    second["Second Entrykey='session:x'hash=0x1234"]
    third["Third Entrykey='cache:abc'hash=0x1234"]
    null["NULL"]

    bucket --> first
    first --> second
    second --> third
    third --> null
```
Sources: [src/dict.c48-57](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L48-L57)

## Incremental Rehashing

Redis implements incremental rehashing to avoid blocking during hash table expansion or contraction:

### Rehashing Process

```mermaid
flowchart TD
    step["dictRehash(d, n)"]
    findbucket["Find non-empty bucket"]
    moveentries["Move all entries in bucket"]
    updateidx["rehashidx++"]
    checkdone["All buckets moved?"]
    cleanup["Cleanup old table"]
    normal["Normal Operationrehashidx = -1Only ht_table[0] active"]
    trigger["Resize TriggerLoad factor threshold"]
    start["Start RehashingAllocate ht_table[1]rehashidx = 0"]
    incremental["Incremental StepsMove buckets graduallyrehashidx++"]
    complete["Complete RehashingSwap tablesrehashidx = -1"]

    step --> findbucket
    findbucket --> moveentries
    moveentries --> updateidx
    updateidx --> checkdone
    checkdone --> findbucket
    checkdone --> cleanup
    normal --> trigger
    trigger --> start
    start --> incremental
    incremental --> complete
    complete --> normal
```
Sources: [src/dict.c400-429](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L400-L429) [src/dict.c329-372](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L329-L372)

### Rehashing Integration

The rehashing process is integrated into normal dictionary operations:

```mermaid
flowchart TD
    timer["Server Cron"]
    microseconds["dictRehashMicroseconds()"]
    timelimit["Process for N microseconds"]
    yield["Yield to other operations"]
    lookup["Dict Lookup"]
    rehashstep["_dictRehashStep()"]
    insert["Dict Insert"]
    delete["Dict Delete"]
    checkboth["Search both tablesif rehashing"]
    continue["Continue operation"]

    timer --> microseconds
    microseconds --> timelimit
    timelimit --> yield
    lookup --> rehashstep
    insert --> rehashstep
    delete --> rehashstep
    rehashstep --> checkboth
    rehashstep --> continue
```
Sources: [src/dict.c463-465](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L463-L465) [src/dict.c441-453](https://github.com/redis/redis/blob/8ad54215/src/dict.c#L441-L453)

## KVStore Layer

The `kvstore` provides a higher-level abstraction that manages multiple dictionaries, primarily used in Redis cluster mode where different hash slots require separate dictionaries.

### KVStore Architecture

```mermaid
flowchart TD
    kvs["kvstore"]
    dicts["dict **dicts"]
    num_dicts["num_dicts"]
    num_dicts_bits["num_dicts_bits"]
    rehashing["list *rehashing"]
    key_count["key_count"]
    bucket_count["bucket_count"]
    dict_size_index["dict_size_index[](Binary Indexed Tree)"]
    dict0["dict[0]Hash Slot 0-1023"]
    dict1["dict[1]Hash Slot 1024-2047"]
    dict2["dict[2]Hash Slot 2048-3071"]
    dictN["dict[N]Hash Slot N*1024..."]
    rehash_list["List of dictscurrently rehashing"]

    kvs --> dicts
    kvs --> num_dicts
    kvs --> num_dicts_bits
    kvs --> rehashing
    kvs --> key_count
    kvs --> bucket_count
    kvs --> dict_size_index
    dicts --> dict0
    dicts --> dict1
    dicts --> dict2
    dicts --> dictN
    rehashing --> rehash_list
    rehash --> list_dict1
    rehash --> list_dictN
```
Sources: [src/kvstore.c37-52](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L37-L52) [src/kvstore.c255-301](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L255-L301)

### Dictionary Selection and Operations

```mermaid
flowchart TD
    kvfind["kvstoreDictFind()"]
    getdict["kvstoreGetDict(didx)"]
    kvadd["kvstoreDictAddRaw()"]
    createifneeded["createDictIfNeeded()"]
    kvdel["kvstoreDictDelete()"]
    freeDictIfNeeded["freeDictIfNeeded()"]
    dictop["Standard dict operation"]
    key["Input Key"]
    hash["Hash Function"]
    slot["Hash Slot"]
    didx["Dict Indexslot % num_dicts"]
    targetdict["Target Dictionary"]

    kvfind --> getdict
    kvadd --> createifneeded
    kvdel --> freeDictIfNeeded
    getdict --> dictop
    createifneeded --> dictop
    freeDictIfNeeded --> dictop
    key --> hash
    hash --> slot
    slot --> didx
    didx --> targetdict
```
Sources: [src/kvstore.c86-88](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L86-L88) [src/kvstore.c164-171](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L164-L171) [src/kvstore.c180-189](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L180-L189)

### Statistics and Memory Management

The kvstore maintains aggregate statistics across all dictionaries using a Binary Indexed Tree (Fenwick Tree) for efficient range queries:

```mermaid
flowchart TD
    flags["kvstore flags"]
    allocondemand["KVSTORE_ALLOCATE_DICTS_ON_DEMAND"]
    freeempty["KVSTORE_FREE_EMPTY_DICTS"]
    keyhist["KVSTORE_ALLOC_META_KEYS_HIST"]
    lazycreate["Create dicts only when needed"]
    cleanup["Free empty dicts automatically"]
    metadata["Track key size histograms"]
    operation["Dict Operation(Add/Remove Key)"]
    update["cumulativeKeyCountAdd()"]
    keycount["Update key_count"]
    nonempty["Update non_empty_dicts"]
    bit["Update Binary Indexed Tree"]
    bitarray["dict_size_index[]"]
    rangequery["O(log n) range queries"]

    flags --> allocondemand
    flags --> freeempty
    flags --> keyhist
    allocondemand --> lazycreate
    freeempty --> cleanup
    keyhist --> metadata
    operation --> update
    update --> keycount
    update --> nonempty
    update --> bit
    bit --> bitarray
    bitarray --> rangequery
```
Sources: [src/kvstore.c138-161](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L138-L161) [src/kvstore.c180-189](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L180-L189) [src/kvstore.c255-301](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c#L255-L301)

## Integration with Redis Core

### Dictionary Types in Redis

Redis uses different `dictType` configurations for various purposes:

| Dictionary Type | Key Type | Value Type | Use Case |
| --- | --- | --- | --- |
| `dbDictType` | `robj*` | `robj*` | Main database |
| `setDictType` | `sds` | `NULL` | Set data type |
| `zsetDictType` | `sds` | `double*` | Sorted set scores |
| `hashDictType` | `hfield` | `sds` | Hash fields |
| `pubsubDictType` | `sds` | `list*` | Pub/Sub channels |

Sources: Referenced in various data type implementations

### Database Integration

```mermaid
flowchart TD
    clusterdb["Cluster Database"]
    kvstore["kvstore *keys"]
    kvexpires["kvstore *expires"]
    slot0["dict[0] - Slot 0-xxx"]
    slot1["dict[1] - Slot xxx-yyy"]
    slotN["dict[N] - Slot yyy-16383"]
    redisdb["redisDb"]
    dict["dict *dict(main keyspace)"]
    expires["dict *expires(expiration times)"]
    blocking_keys["dict *blocking_keys"]
    ready_keys["dict *ready_keys"]

    clusterdb --> kvstore
    clusterdb --> kvexpires
    kvstore --> slot0
    kvstore --> slot1
    kvstore --> slotN
    redisdb --> dict
    redisdb --> expires
    redisdb --> blocking_keys
    redisdb --> ready_keys
```
Sources: Referenced in database and cluster implementations

The dictionary and kvstore systems form the backbone of Redis's data storage, providing efficient hash table operations with memory optimization, incremental rehashing, and support for both single-instance and clustered deployments.

Sources: [src/dict.c](https://github.com/redis/redis/blob/8ad54215/src/dict.c) [src/dict.h](https://github.com/redis/redis/blob/8ad54215/src/dict.h) [src/kvstore.c](https://github.com/redis/redis/blob/8ad54215/src/kvstore.c) [src/kvstore.h](https://github.com/redis/redis/blob/8ad54215/src/kvstore.h)
