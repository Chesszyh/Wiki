# Bitboards

Relevant source files

-   [src/chess/bitboard.h](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h)
-   [src/syzygy/syzygy.cc](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.cc)
-   [src/syzygy/syzygy.h](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.h)
-   [src/syzygy/syzygy\_test.cc](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy_test.cc)
-   [src/utils/bititer.h](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h)

## Purpose and Scope

This document describes the bitboard implementation in Leela Chess Zero (lc0). Bitboards are a fundamental data structure used for efficient board representation and move generation in chess engines. This page covers the `BitBoard` class, bitboard operations, and the magic bitboard technique used for efficient sliding piece movement generation.

For information about how positions are encoded for neural network input, see [Position Encoding and History](/LeelaChessZero/lc0/4.2-position-encoding-and-history).

## What is a Bitboard?

A bitboard is a 64-bit integer where each bit represents a square on the chess board. This representation allows for efficient operations using bitwise operations like AND, OR, and XOR.

In lc0, bit enumeration goes from bottom to top, from left to right:

-   Square a1 is bit 0
-   Square h1 is bit 7
-   Square a2 is bit 8
-   ...and so on up to square h8 at bit 63

```mermaid
flowchart TD
    A8["a8 (56)"]
    B8["b8 (57)"]
    C8["c8 (58)"]
    D8["d8 (59)"]
    E8["e8 (60)"]
    F8["f8 (61)"]
    G8["g8 (62)"]
    H8["h8 (63)"]
    A7["a7 (48)"]
    B7["b7 (49)"]
    C7["c7 (50)"]
    D7["d7 (51)"]
    E7["e7 (52)"]
    F7["f7 (53)"]
    G7["g7 (54)"]
    H7["h7 (55)"]
    A6["a6 (40)"]
    B6["b6 (41)"]
    C6["c6 (42)"]
    D6["d6 (43)"]
    E6["e6 (44)"]
    F6["f6 (45)"]
    G6["g6 (46)"]
    H6["h6 (47)"]
    A5["a5 (32)"]
    B5["b5 (33)"]
    C5["c5 (34)"]
    D5["d5 (35)"]
    E5["e5 (36)"]
    F5["f5 (37)"]
    G5["g5 (38)"]
    H5["h5 (39)"]
    A4["a4 (24)"]
    B4["b4 (25)"]
    C4["c4 (26)"]
    D4["d4 (27)"]
    E4["e4 (28)"]
    F4["f4 (29)"]
    G4["g4 (30)"]
    H4["h4 (31)"]
    A3["a3 (16)"]
    B3["b3 (17)"]
    C3["c3 (18)"]
    D3["d3 (19)"]
    E3["e3 (20)"]
    F3["f3 (21)"]
    G3["g3 (22)"]
    H3["h3 (23)"]
    A2["a2 (8)"]
    B2["b2 (9)"]
    C2["c2 (10)"]
    D2["d2 (11)"]
    E2["e2 (12)"]
    F2["f2 (13)"]
    G2["g2 (14)"]
    H2["h2 (15)"]
    A1["a1 (0)"]
    B1["b1 (1)"]
    C1["c1 (2)"]
    D1["d1 (3)"]
    E1["e1 (4)"]
    F1["f1 (5)"]
    G1["g1 (6)"]
    H1["h1 (7)"]

    A8 --> B8
    B8 --> C8
    C8 --> D8
    D8 --> E8
    E8 --> F8
    F8 --> G8
    G8 --> H8
    A7 --> B7
    B7 --> C7
    C7 --> D7
    D7 --> E7
    E7 --> F7
    F7 --> G7
    G7 --> H7
    A6 --> B6
    B6 --> C6
    C6 --> D6
    D6 --> E6
    E6 --> F6
    F6 --> G6
    G6 --> H6
    A5 --> B5
    B5 --> C5
    C5 --> D5
    D5 --> E5
    E5 --> F5
    F5 --> G5
    G5 --> H5
    A4 --> B4
    B4 --> C4
    C4 --> D4
    D4 --> E4
    E4 --> F4
    F4 --> G4
    G4 --> H4
    A3 --> B3
    B3 --> C3
    C3 --> D3
    D3 --> E3
    E3 --> F3
    F3 --> G3
    G3 --> H3
    A2 --> B2
    B2 --> C2
    C2 --> D2
    D2 --> E2
    E2 --> F2
    F2 --> G2
    G2 --> H2
    A1 --> B1
    B1 --> C1
    C1 --> D1
    D1 --> E1
    E1 --> F1
    F1 --> G1
    G1 --> H1
```
Sources: [src/chess/bitboard.h41-43](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L41-L43)

## BitBoard Class

The `BitBoard` class encapsulates a 64-bit integer and provides methods for manipulating the bits. It's defined in `src/chess/bitboard.h`.

```mermaid
flowchart TD
    classId_BitBoard_0["BitBoard"]
```
Sources: [src/chess/bitboard.h43-162](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L43-L162)

### Key BitBoard Operations

The BitBoard class offers several operations:

1.  **Creation and conversion**:

    -   Default constructor creates an empty bitboard
    -   Construction from a 64-bit integer
    -   `FromSquare` creates a bitboard with only one bit set
    -   `as_int()` returns the underlying 64-bit integer
2.  **Bit manipulation**:

    -   `set(square)`: Sets the bit for a specific square to 1
    -   `reset(square)`: Sets the bit for a specific square to 0
    -   `get(square)`: Gets the value of the bit for a specific square
    -   `set_if(square, condition)`: Sets the bit only if the condition is true
3.  **Bitboard queries**:

    -   `count()`: Counts the number of set bits (implemented using population count instructions when available)
    -   `count_few()`: Optimized for counting a small number of set bits
    -   `empty()`: Checks if all bits are 0
    -   `intersects(other)`: Checks if any bit is set in both bitboards
4.  **Bitboard transformations**:

    -   `Mirror()`: Flips the board vertically, mirroring black and white side of the board
5.  **Operators**:

    -   `|` (OR): Union of two bitboards
    -   `&` (AND): Intersection of two bitboards
    -   `-` (Subtraction): Difference between bitboards
6.  **Iteration**:

    -   `begin()` and `end()` methods support range-based for loops over set bits

Sources: [src/chess/bitboard.h45-158](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L45-L158) [src/utils/bititer.h36-121](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h#L36-L121)

### BitBoard Iteration

The `BitBoard` class provides iteration over set bits using the `BitIterator` class. This allows iterating over all the pieces of a certain type on the board.

```
// Example of iterating over all squares set in a bitboard
for (auto square : some_bitboard) {
    // Do something with each set square
}
```
The implementation uses the `BitIterator` class defined in `src/utils/bititer.h`, which efficiently finds and iterates through set bits using bit manipulation techniques:

**BitIterator Implementation Details**

```mermaid
flowchart TD
    classId_BitIterator_1["BitIterator<T, Convert>"]
    classId_BitBoard_2["BitBoard"]
    classId_IterateBits_3["IterateBits"]
```
The `BitIterator` advances through set bits using the expression `value_ &= (value_ - 1)`, which efficiently clears the lowest set bit on each iteration. The `GetLowestBit` function uses platform-specific bit scan instructions:

| Platform | Implementation |
| --- | --- |
| MSVC 64-bit | `_BitScanForward64` |
| MSVC 32-bit | `_BitScanForward` with 64-bit handling |
| GCC/Clang | `__builtin_ctzll` |

Sources: [src/chess/bitboard.h112-117](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L112-L117) [src/utils/bititer.h37-54](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h#L37-L54) [src/utils/bititer.h92-110](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h#L92-L110) [src/utils/bititer.h112-121](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h#L112-L121)

## Chess Board Representation and Bitboard Transformations

### Board Transformations

The `src/utils/bititer.h` file provides several board transformation functions for manipulating bitboards:

**Board Transformation Functions**

```mermaid
flowchart TD
    BB["BitBoard (uint64_t)"]
    RBB["ReverseBitsInBytes()"]
    RBIB["ReverseBytesInBytes()"]
    TBIB["TransposeBitsInBytes()"]
    HM["Flipped Board"]
    VM["Mirrored Board"]
    DT["Transposed Board"]

    BB --> RBB
    BB --> RBIB
    BB --> TBIB
    RBB --> HM
    RBIB --> VM
    TBIB --> DT
```
| Transform | Purpose | Implementation |
| --- | --- | --- |
| `ReverseBitsInBytes` | Horizontal mirror (flip left-right) | Bit manipulation with masks |
| `ReverseBytesInBytes` | Vertical mirror (flip top-bottom) | Byte reversal operations |
| `TransposeBitsInBytes` | Diagonal transpose (A1â†”H8) | Complex bit permutation |

The `BitBoard::Mirror()` method uses `ReverseBytesInBytes` to flip the board vertically, which is used for flipping between white and black perspectives.

### Bitboard Usage in Syzygy Tablebases

The Syzygy tablebase implementation demonstrates practical bitboard usage:

**Piece Type Extraction**

```mermaid
flowchart TD
    CB["ChessBoard"]
    Side["Side Bitboards"]
    PT["Piece Type Bitboards"]
    Count["Piece Count"]
    Squares["Square List"]

    CB --> Side
    CB --> PT
    Side --> PT
    PT --> Count
    PT --> Squares
```
The `count_pieces` function in syzygy code shows typical bitboard operations:

```
// Extract pieces of specific type for a side
const BitBoard all = theirs ? pos.theirs() : pos.ours();
return (all & pos.queens()).count_few();
```
Sources: [src/chess/bitboard.h107](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L107-L107) [src/utils/bititer.h66-89](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h#L66-L89) [src/syzygy/syzygy.cc185-204](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.cc#L185-L204) [src/syzygy/syzygy.cc206-225](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.cc#L206-L225)

## Move Generation and Bitboard Operations

### Bitboard Operations for Move Generation

Move generation in lc0 relies heavily on bitboard operations. The core operations include:

**Essential Bitboard Operations**

```mermaid
flowchart TD
    BB1["BitBoard A"]
    AND["A & B"]
    BB2["BitBoard B"]
    Result1["Common squares"]
    OR["A | B"]
    Result2["All squares"]
    MINUS["A - B"]
    Result3["A without B"]
    COUNT["count() / count_few()"]
    Result4["Number of pieces"]

    BB1 --> AND
    BB2 --> AND
    AND --> Result1
    BB1 --> OR
    BB2 --> OR
    OR --> Result2
    BB1 --> MINUS
    BB2 --> MINUS
    MINUS --> Result3
    BB1 --> COUNT
    COUNT --> Result4
```
The `count_few()` method is optimized for sparse bitboards (typically used for piece types other than pawns):

| Condition | Implementation |
| --- | --- |
| `NO_POPCNT` defined | Software bit counting loop |
| Hardware POPCNT available | Delegates to `count()` |

### Practical Move Generation Examples

The Syzygy tablebase code demonstrates typical move generation patterns:

**Capture Detection**

```mermaid
flowchart TD
    Move["Move"]
    TC["pos.theirs().get(move.to())"]
    Capture["Simple Capture"]
    EP["Check En Passant"]
    Pawn["pos.pawns().get(move.from())"]
    FileCheck["move.from().file() != move.to().file()"]
    EPCapture["En Passant Capture"]
    NotCapture["Not a Capture"]

    Move --> TC
    TC --> Capture
    TC --> EP
    EP --> Pawn
    Pawn --> FileCheck
    FileCheck --> EPCapture
    FileCheck --> NotCapture
    Pawn --> NotCapture
```
**Square Filling for Tablebase Lookup**

```mermaid
flowchart TD
    Pos["ChessBoard position"]
    GetPieces["pieces(pos, type, side)"]
    BB["BitBoard for piece type"]
    Iterate["for (auto sq : bb)"]
    Fill["p[i++] = sq.as_idx() ^ mirror"]

    Pos --> GetPieces
    GetPieces --> BB
    BB --> Iterate
    Iterate --> Fill
```
The `fill_squares` function shows how bitboards are converted to square arrays for tablebase indexing, applying board mirroring when necessary.

Sources: [src/chess/bitboard.h74-86](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L74-L86) [src/chess/bitboard.h129-158](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L129-L158) [src/syzygy/syzygy.cc227-235](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.cc#L227-L235) [src/syzygy/syzygy.cc851-861](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.cc#L851-L861)

## Advanced Bitboard Techniques

### Platform-Specific Optimizations

The bitboard implementation includes several platform-specific optimizations:

**Bit Scanning Functions**

```mermaid
flowchart TD
    GetLowestBit["GetLowestBit(uint64_t)"]
    MSVC64["_BitScanForward64"]
    MSVC32["_BitScanForward + split handling"]
    GCC["__builtin_ctzll"]
    Result["Bit index"]

    GetLowestBit --> MSVC64
    GetLowestBit --> MSVC32
    GetLowestBit --> GCC
    MSVC64 --> Result
    MSVC32 --> Result
    GCC --> Result
```
**Population Count Implementations**

```mermaid
flowchart TD
    Count["BitBoard::count()"]
    Check["Hardware POPCNT?"]
    POPCNT64["_mm_popcnt_u64"]
    POPCNT32["__popcnt + __popcnt"]
    BUILTIN["__builtin_popcountll"]
    SOFTWARE["Software implementation"]
    LOOP["Bit manipulation loop"]

    Count --> Check
    Check --> POPCNT64
    Check --> POPCNT32
    Check --> BUILTIN
    Check --> SOFTWARE
    SOFTWARE --> LOOP
```
The software implementation uses the classic bit manipulation technique:

```
x -= (x >> 1) & 0x5555555555555555;
x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
// ... continued bit manipulation
```
### Integration with Position Representation

Bitboards integrate with the broader position representation system:

**Position to Bitboard Conversion**

```mermaid
flowchart TD
    Pos["Position"]
    Side["our_pieces_ / their_pieces_"]
    Type["Piece type bitboards"]
    AND["Bitwise AND"]
    Pieces["Specific piece bitboard"]
    Count["count_few()"]
    Iter["Iteration"]
    Ops["Bitboard operations"]

    Pos --> Side
    Pos --> Type
    Side --> AND
    Type --> AND
    AND --> Pieces
    Pieces --> Count
    Pieces --> Iter
    Pieces --> Ops
```
The Syzygy implementation shows how this is used in practice for determining piece material and positions for tablebase lookup.

Sources: [src/utils/bititer.h37-54](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h#L37-L54) [src/chess/bitboard.h55-86](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L55-L86) [src/syzygy/syzygy.cc185-225](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.cc#L185-L225)

## Performance Considerations

Bitboards provide several performance advantages in the lc0 engine:

### Hardware Acceleration

| Operation | Hardware Support | Performance Benefit |
| --- | --- | --- |
| Population count | POPCNT instruction | O(1) bit counting |
| Bit scanning | BSF/BSR instructions | Fast lowest bit finding |
| Parallel operations | 64-bit ALU operations | Multiple squares at once |

### Memory Efficiency

**Compact Board Representation**

```mermaid
flowchart TD
    Traditional["Traditional 8x8 array"]
    Memory1["High memory usage"]
    Bitboard["BitBoard representation"]
    Memory2["Compact storage"]
    Cache["Better cache locality"]
    Copy["Fast copying"]
    Compare["Fast comparison"]

    Traditional --> Memory1
    Bitboard --> Memory2
    Memory2 --> Cache
    Memory2 --> Copy
    Memory2 --> Compare
```
### Algorithmic Efficiency

The bitboard approach enables:

1.  **Parallel piece operations**: Operating on all pieces of a type simultaneously
2.  **Fast intersection tests**: Using bitwise AND to check piece interactions
3.  **Efficient iteration**: Using bit manipulation to iterate only over occupied squares

The `count_few()` optimization demonstrates performance consideration for sparse bitboards:

```
// Optimized for pieces with few instances (Q, R, N, B)
// Uses bit-clearing loop when POPCNT not available
x &= x - 1;  // Clears rightmost set bit
```
### Tablebase Integration Performance

The Syzygy tablebase code shows real-world bitboard performance patterns:

-   Direct bitboard access for piece counting
-   Efficient iteration over piece positions
-   Fast capture detection using bitboard intersections

Sources: [src/chess/bitboard.h55-86](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/chess/bitboard.h#L55-L86) [src/utils/bititer.h37-54](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/utils/bititer.h#L37-L54) [src/syzygy/syzygy.cc185-204](https://github.com/LeelaChessZero/lc0/blob/b4e98c19/src/syzygy/syzygy.cc#L185-L204)

## Summary

Bitboards are a key data structure in the Leela Chess Zero engine, providing efficient representation of the chess board and fast move generation. The implementation includes:

-   The `BitBoard` class for manipulating 64-bit board representations
-   Multiple bitboards to track different piece types and colors
-   Magic bitboards for efficient sliding piece move generation
-   Precomputed attack tables for non-sliding pieces
-   Two-step move generation (pseudolegal followed by legality check)

This efficient representation contributes significantly to the engine's performance, allowing it to evaluate positions and generate moves quickly.
