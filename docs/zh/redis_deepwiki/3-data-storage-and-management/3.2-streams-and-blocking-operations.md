# 流 (Streams) 与阻塞操作

相关源文件

-   [src/blocked.c](https://github.com/redis/redis/blob/8ad54215/src/blocked.c)
-   [src/stream.h](https://github.com/redis/redis/blob/8ad54215/src/stream.h)
-   [src/t\_stream.c](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c)
-   [tests/unit/type/stream-cgroups.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/type/stream-cgroups.tcl)
-   [tests/unit/type/stream.tcl](https://github.com/redis/redis/blob/8ad54215/tests/unit/type/stream.tcl)

流 (Streams) 是 Redis 的一种数据类型，实现了带有消费者组 (consumer group) 功能和复杂阻塞操作支持的仅追加日志。它们提供了类似时间序列的功能，具有高效的范围查询、消息传递保证，以及支持实时数据处理的客户端阻塞机制。其实现结合了基数树 (`rax`) 与压缩的 listpack 以实现高效存储，并与 Redis 通用的阻塞客户端系统集成，以实现响应式的事件驱动操作。

阻塞操作系统允许客户端在多个流键上高效地等待新数据，并在添加条目、删除键或发生超时时自动解除阻塞。这种集成使 Redis 流既能作为持久化日志，也能作为实时消息传递系统。

有关列表和有序集合等其他数据类型的信息，请参阅第 3.1 页。有关流数据持久化的详细信息，请参阅第 7 页。

## 核心架构与数据结构

### 流数据结构概览

```mermaid
flowchart TD
    STREAM["stream 结构体"]
    RAX["rax *rax 基数树存储"]
    LENGTH["uint64_t length 当前条目数"]
    LASTID["streamID last_id 最新条目 ID"]
    FIRSTID["streamID first_id 第一个非墓碑 ID"]
    MAXDEL["streamID max_deleted_entry_id 最大已删除 ID"]
    ENTRIES["uint64_t entries_added 已添加条目总数"]
    CGROUPS["rax *cgroups 消费者组"]
    CGROUPSREF["rax *cgroups_ref ID 到 CG 的索引"]
    MINCGID["streamID min_cgroup_last_id 最小消费者组 ID"]
    STREAMID["streamID"]
    MS["uint64_t ms 毫秒时间戳"]
    SEQ["uint64_t seq 序列号"]
    RAXNODE1["Listpack 节点 1 主条目 + 项目"]
    RAXNODE2["Listpack 节点 2 主条目 + 项目"]
    RAXNODEN["Listpack 节点 N 主条目 + 项目"]

    STREAM --> RAX
    STREAM --> LENGTH
    STREAM --> LASTID
    STREAM --> FIRSTID
    STREAM --> MAXDEL
    STREAM --> ENTRIES
    STREAM --> CGROUPS
    STREAM --> CGROUPSREF
    STREAM --> MINCGID
    RAX --> RAXNODE1
    RAX --> RAXNODE2
    RAX --> RAXNODEN
    LASTID --> STREAMID
    FIRSTID --> STREAMID
    MAXDEL --> STREAMID
    MINCGID --> STREAMID
```

**来源：** [src/stream.h16-27](https://github.com/redis/redis/blob/8ad54215/src/stream.h#L16-L27) [src/stream.h11-14](https://github.com/redis/redis/blob/8ad54215/src/stream.h#L11-L14) [src/t\_stream.c51-68](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L51-L68)

`stream` 结构使用基数树 (`rax`) 将条目存储在 listpack 中，提供高效的范围查询和内存压缩。每个流都维护有关其边界 (`first_id`, `last_id`)、删除状态 (`max_deleted_entry_id`) 和消费者组追踪的元数据。`streamID` 是一个由毫秒时间戳和序列号组成的 128 位标识符。

### 消费者组架构

```mermaid
flowchart TD
    CG["streamCG 消费者组结构"]
    CGLASTID["streamID last_id 最后递送 ID"]
    ENTRIESREAD["long long entries_read 组读取总数"]
    PEL["rax *pel 待处理条目列表"]
    CONSUMERS["rax *consumers 消费者实例"]
    CONSUMER["streamConsumer 消费者结构"]
    SEENTIME["mstime_t seen_time 最后活动时间"]
    ACTIVETIME["mstime_t active_time 最后成功读取时间"]
    NAME["sds name 消费者标识符"]
    CONSUMERPAL["rax *pel 消费者 PEL"]
    NACK["streamNACK 结构"]
    DELIVERYTIME["mstime_t delivery_time 最后递送时间"]
    DELIVERYCOUNT["uint64_t delivery_count 递送尝试次数"]
    NACKCONS["streamConsumer *consumer 当前持有者"]
    CGREFNODE["listNode *cgroup_ref_node 在 cgroups_ref 中的引用"]

    CG --> CGLASTID
    CG --> ENTRIESREAD
    CG --> PEL
    CG --> CONSUMERS
    CONSUMERS --> CONSUMER
    CONSUMER --> SEENTIME
    CONSUMER --> ACTIVETIME
    CONSUMER --> NAME
    CONSUMER --> CONSUMERPAL
    PEL --> NACK
    CONSUMERPAL --> NACK
    NACK --> DELIVERYTIME
    NACK --> DELIVERYCOUNT
    NACK --> NACKCONS
    NACK --> CGREFNODE
```

**来源：** [src/stream.h57-76](https://github.com/redis/redis/blob/8ad54215/src/stream.h#L57-L76) [src/stream.h78-92](https://github.com/redis/redis/blob/8ad54215/src/stream.h#L78-L92) [src/stream.h95-101](https://github.com/redis/redis/blob/8ad54215/src/stream.h#L95-L101)

消费者组允许多个消费者以递送保证来处理流条目。待处理条目列表 (PEL) 追踪组和消费者层面未确认的消息。每个 `streamNACK` 代表已递送但尚未确认的消息，并追踪递送时间、次数和消费者归属。`cgroup_ref_node` 提供了流中 `cgroups_ref` 索引条目的引用，以实现高效查找。

## 流条目存储与压缩

### Listpack 编码结构

```mermaid
flowchart TD
    FLAGS["flags 条目标志"]
    MSDIFF["ms-diff 相对于主条目的毫秒偏移"]
    SEQDIFF["seq-diff 相对于主条目的序列号偏移"]
    NUMFIELDS2["num-fields 字段数 (如果不同)"]
    EFIELDS["条目字段/值"]
    LPCOUNT["lp-count 条目大小"]
    COUNT["count 有效条目数"]
    DELETED["deleted 已删除条目数"]
    NUMFIELDS["num-fields 字段数"]
    FIELD1["字段 1"]
    FIELDN["字段 N"]
    ZERO["0 终止符"]

    FLAGS --> MSDIFF
    MSDIFF --> SEQDIFF
    SEQDIFF --> NUMFIELDS2
    NUMFIELDS2 --> EFIELDS
    EFIELDS --> LPCOUNT
    COUNT --> DELETED
    DELETED --> NUMFIELDS
    NUMFIELDS --> FIELD1
    FIELD1 --> FIELDN
    FIELDN --> ZERO
```

**来源：** [src/t\_stream.c14-19](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L14-L19) [src/t\_stream.c490-520](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L490-L520) [src/t\_stream.c601-652](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L601-L652)

流条目以压缩形式存储在 listpack 中。每个 listpack 节点包含：

1.  一个**主条目** (master entry)，定义了节点中所有条目的公共字段。
2.  多个**流条目**，存储相对于主条目的增量。

条目标志包括：

-   `STREAM_ITEM_FLAG_NONE` (0)：无特殊标志。
-   `STREAM_ITEM_FLAG_DELETED` (1<<0)：条目已删除（墓碑）。
-   `STREAM_ITEM_FLAG_SAMEFIELDS` (1<<1)：条目具有与主条目相同的字段。

当设置了 `SAMEFIELDS` 标志时，条目会省略字段名称和字段数量，仅存储值，当条目具有一致的架构 (schema) 时，这可以显著节省内存。

## 核心流操作

### 流添加流程 (XADD)

```mermaid
flowchart TD
    XADD["XADD 命令"]
    VALIDATE["streamAppendItem()"]
    IDGEN["生成/验证 ID"]
    FINDNODE["查找/创建 Listpack 节点"]
    COMPRESS["检查字段压缩"]
    APPEND["追加到 Listpack"]
    UPDATE["更新流元数据"]
    SIGNAL["signalKeyAsReady()"]
    AUTOID["streamNextID() 自动生成 ID"]
    SPECID["use_id 特定 ID 验证"]
    SEQAUTO["seq_given 序列号处理"]
    NODECHECK["检查节点大小/条目数"]
    NEWNODE["需要时创建新节点"]
    MASTERENTRY["创建主条目"]
    COMPRESSCHECK["检查字段压缩情况"]

    XADD --> VALIDATE
    VALIDATE --> IDGEN
    IDGEN --> FINDNODE
    FINDNODE --> COMPRESS
    COMPRESS --> APPEND
    APPEND --> UPDATE
    UPDATE --> SIGNAL
    IDGEN --> AUTOID
    IDGEN --> SPECID
    IDGEN --> SEQAUTO
    FINDNODE --> NODECHECK
    NODECHECK --> NEWNODE
    NEWNODE --> MASTERENTRY
    COMPRESS --> COMPRESSCHECK
```

**来源：** [src/t\_stream.c420-662](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L420-L662) [src/t\_stream.c130-139](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L130-L139)

`streamAppendItem()` 函数（由 `XADD` 调用）处理：

1.  **ID 生成或验证**：
    -   通过 `streamNextID()` 自动生成 ID。
    -   验证用户提供的 ID。
    -   使用 `seq_given` 标志处理序列号。
2.  **Listpack 节点管理**：
    -   根据 `stream_node_max_bytes` 和 `stream_node_max_entries` 检查当前节点是否能容纳新条目。
    -   在需要时创建带有主条目的新节点。
3.  **字段压缩**：
    -   检查条目字段是否与主条目字段匹配。
    -   为压缩设置 `STREAM_ITEM_FLAG_SAMEFIELDS` 标志。
4.  **流元数据更新**：
    -   更新 `length`, `entries_added`, `first_id` 和 `last_id`。
    -   通过 `signalKeyAsReady()` 通知阻塞的客户端。

### 消费者组读取流程 (XREADGROUP)

```mermaid
flowchart TD
    XREADGROUP["XREADGROUP 命令"]
    FINDCG["streamLookupCG() 查找消费者组"]
    FINDCONS["streamLookupConsumer() 查找/创建消费者"]
    READTYPE["确定读取类型"]
    HISTORY["读取历史 (ID < last_id)"]
    PENDING["读取待处理 (从 PEL)"]
    NEW["读取新消息 (ID > last_id)"]
    ADDPEL["streamReplyWithRange() 添加到 PEL"]
    UPDATECG["streamUpdateCGroupLastId() 更新组"]
    IDSPECIFIC["特定 ID：从历史读取"]
    GREATERTHAN["'>'：仅读取新消息"]
    FROMSTART["'0'：从流开头读取"]
    CREATEPEL["创建 PEL 条目"]
    NACKENTRY["streamCreateNACK()"]
    LINKENTRY["streamLinkCGroupToEntry()"]
    NOACK["NOACK 选项：跳过 PEL"]

    XREADGROUP --> FINDCG
    FINDCG --> FINDCONS
    FINDCONS --> READTYPE
    READTYPE --> HISTORY
    READTYPE --> PENDING
    READTYPE --> NEW
    NEW --> ADDPEL
    ADDPEL --> UPDATECG
    READTYPE --> IDSPECIFIC
    READTYPE --> GREATERTHAN
    READTYPE --> FROMSTART
    ADDPEL --> CREATEPEL
    CREATEPEL --> NACKENTRY
    NACKENTRY --> LINKENTRY
    CREATEPEL --> NOACK
```

**来源：** [src/t\_stream.c3000-3300](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L3000-L3300) [tests/unit/type/stream-cgroups.tcl46-74](https://github.com/redis/redis/blob/8ad54215/tests/unit/type/stream-cgroups.tcl#L46-L74) [tests/unit/type/stream-cgroups.tcl180-204](https://github.com/redis/redis/blob/8ad54215/tests/unit/type/stream-cgroups.tcl#L180-L204)

`XREADGROUP` 命令实现了消费者组读取，包含三种主要场景：

1.  **新消息 (ID = `>`)**：
    -   读取比组内 `last_id` 更新的消息。
    -   将条目添加到待处理条目列表 (PEL)。
    -   更新消费者组的 `last_id`。
2.  **历史 (特定 ID)**：
    -   从流中的特定点读取消息。
    -   用于回放历史或从故障中恢复。
3.  **待处理消息 (从 PEL)**：
    -   检索已经递送但尚未确认的消息。
    -   允许消费者重新处理处理失败的消息。

`NOACK` 选项可用于跳过向 PEL 添加条目的步骤，这在只读操作或不需要确认时很有用。

## 客户端阻塞操作系统

### 阻塞客户端生命周期

```mermaid
flowchart TD
    CLIENT["客户端请求 XREAD/XREADGROUP BLOCK"]
    NODATA["无数据可用"]
    BLOCKFN["blockForKeys() 在流键上阻塞客户端"]
    SETSTATE["设置 CLIENT_BLOCKED 标志位 btype = BLOCKED_STREAM"]
    REGISTER["在 db->blocking_keys 中注册：键 → 列表"]
    TIMEOUT["addClientToTimeoutTable() 超时追踪"]
    BLOCKED["客户端处于阻塞状态 查询缓冲区累积"]
    DATAAVAIL["数据可用或键被修改"]
    SIGNAL["signalKeyAsReady() 添加到 server.ready_keys"]
    HANDLE["handleClientsBlockedOnKeys() 在事件循环中处理"]
    UNBLOCK["unblockClientOnKey() 移除阻塞状态"]
    REPROCESS["processCommandAndResetClient() 重新执行原始命令"]
    RESPONSE["向客户端发送响应"]
    BSTATE["c->bstate 阻塞状态"]
    BTYPE["btype = BLOCKED_STREAM"]
    KEYS["keys 字典 阻塞的流键"]
    CLIENTTIMEOUT["超时值"]
    UNBLOCKNOKEY["unblock_on_nokey 标志位"]
    BLOCKEDCLIENTS["server.blocked_clients"]
    BLOCKEDTYPES["server.blocked_clients_by_type[BLOCKED_STREAM]"]
    UNBLOCKEDCLIENTS["server.unblocked_clients"]
    READYKEYS["server.ready_keys"]

    CLIENT --> NODATA
    NODATA --> BLOCKFN
    BLOCKFN --> SETSTATE
    SETSTATE --> REGISTER
    REGISTER --> TIMEOUT
    TIMEOUT --> BLOCKED
    DATAAVAIL --> SIGNAL
    SIGNAL --> HANDLE
    HANDLE --> UNBLOCK
    UNBLOCK --> REPROCESS
    REPROCESS --> RESPONSE
    SETSTATE --> BSTATE
    REGISTER --> BLOCKEDCLIENTS
    SIGNAL --> READYKEYS
    UNBLOCK --> UNBLOCKEDCLIENTS
```

**来源：** [src/blocked.c17-46](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L17-L46) [src/blocked.c61-86](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L61-L86) [src/blocked.c387-437](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L387-L437) [src/blocked.c659-700](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L659-L700)

阻塞操作系统通过精密的客户端状态管理系统实现了对流数据的高效等待：

1.  **阻塞注册**：
    -   `blockForKeys()` 将客户端注册在特定的流键上，类型为 `BLOCKED_STREAM`。
    -   客户端被添加到每个数据库的 `blocking_keys` 字典中，以便快速查找。
    -   全局计数器按类型追踪被阻塞客户端的统计数据。
2.  **状态管理**：
    -   `CLIENT_BLOCKED` 标志位防止在阻塞状态下处理命令。
    -   阻塞期间，查询缓冲区会累积命令。
    -   通过 `addClientToTimeoutTable()` 进行超时管理。
3.  **解除阻塞流程**：
    -   流的修改触发 `signalKeyAsReady()`，将键排队到 `server.ready_keys`。
    -   `handleClientsBlockedOnKeys()` 在事件循环中处理就绪的键。
    -   带有 `CLIENT_REEXECUTING_COMMAND` 标志的命令会被原子性地重新处理。

### 流特定的阻塞特性

```mermaid
flowchart TD
    XREAD["XREAD BLOCK timeout STREAMS key1 key2 ... id1 id2 ..."]
    XREADGROUP["XREADGROUP GROUP group consumer BLOCK timeout STREAMS key1 id1"]
    STREAMCHECK["检查流是否存在及数据可用性"]
    IMMEDIATELY["如果数据可用则立即返回"]
    BLOCKSTREAM["以 BLOCKED_STREAM 类型阻塞"]
    UNBLOCKKEY["在键事件上解除阻塞"]
    KEYDELETE["键删除：signalDeletedKeyAsReady()"]
    KEYADD["键添加：XADD 触发 signalKeyAsReady()"]
    TYPECHANGE["类型变更：键被不同类型覆盖"]
    STREAMSPECIFIC["流特定行为"]
    LASTENTRY["带有 '+' ID 的 XREAD：立即返回最后一条条目"]
    GREATERTHAN["带有 '>' 的 XREADGROUP：仅等待新条目"]
    GROUPVALIDATION["消费者组验证：NOGROUP 错误处理"]

    XREAD --> STREAMCHECK
    XREADGROUP --> STREAMCHECK
    STREAMCHECK --> IMMEDIATELY
    STREAMCHECK --> BLOCKSTREAM
    BLOCKSTREAM --> UNBLOCKKEY
    UNBLOCKKEY --> KEYDELETE
    UNBLOCKKEY --> KEYADD
    UNBLOCKKEY --> TYPECHANGE
    BLOCKSTREAM --> STREAMSPECIFIC
    STREAMSPECIFIC --> LASTENTRY
    STREAMSPECIFIC --> GREATERTHAN
    STREAMSPECIFIC --> GROUPVALIDATION
```

**来源：** [tests/unit/type/stream-cgroups.tcl221-285](https://github.com/redis/redis/blob/8ad54215/tests/unit/type/stream-cgroups.tcl#L221-L285) [tests/unit/type/stream.tcl422-480](https://github.com/redis/redis/blob/8ad54215/tests/unit/type/stream.tcl#L422-L480) [src/blocked.c570-576](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L570-L576)

流阻塞操作具有专门的行为：

1.  **键状态变更**：
    -   `unblock_on_nokey` 标志位支持在键被删除或更改类型时解除阻塞。
    -   当消费者组被销毁时，XREADGROUP 操作解除阻塞并返回 `NOGROUP` 错误。
    -   类型变更（例如 SET 覆盖了流）会触发 `WRONGTYPE` 错误。
2.  **流特定 ID**：
    -   如果流非空，带有 `+` ID 的 `XREAD` 会立即返回最后一条条目。
    -   带有 `>` ID 的 `XREADGROUP` 仅等待超出组内 `last_id` 的新条目。
    -   在解除阻塞期间进行消费者组验证。
3.  **错误处理**：
    -   被阻塞的客户端可能因错误（超时、键删除、类型变更）而解除阻塞。
    -   `updateStatsOnUnblock()` 确保正确记录命令统计数据。

### 与流操作的集成

```mermaid
flowchart TD
    XADD["XADD 流键 字段 值"]
    APPENDITEM["streamAppendItem() 将条目添加到流"]
    UPDATEMETA["更新流元数据：length, last_id, entries_added"]
    SIGNALREADY["signalKeyAsReady(db, key, OBJ_STREAM) 通知阻塞客户端"]
    CHECKBLOCKED["getBlockedTypeByType(OBJ_STREAM) 返回 BLOCKED_STREAM"]
    FINDCLIENTS["dictFind(db->blocking_keys, key) 获取阻塞客户端列表"]
    ADDREADY["如果尚未存在，则添加到 server.ready_keys"]
    EVENTLOOP["beforeSleep() 事件循环"]
    HANDLEREADY["handleClientsBlockedOnKeys() 处理 ready_keys 列表"]
    ITERATECLIENTS["为每个就绪键迭代阻塞的客户端"]
    CHECKCOMPAT["检查键类型兼容性：流 vs 预期类型"]
    UNBLOCKCLIENT["unblockClientOnKey() 重新处理命令"]
    RELEASEENTRY["releaseBlockedEntry() 从 blocking_keys 中移除"]
    UPDATECOUNTERS["更新阻塞客户端计数器"]
    CLEANBSTATE["清除 c->bstate.keys"]

    XADD --> APPENDITEM
    APPENDITEM --> UPDATEMETA
    UPDATEMETA --> SIGNALREADY
    SIGNALREADY --> CHECKBLOCKED
    CHECKBLOCKED --> FINDCLIENTS
    FINDCLIENTS --> ADDREADY
    EVENTLOOP --> HANDLEREADY
    HANDLEREADY --> ITERATECLIENTS
    ITERATECLIENTS --> CHECKCOMPAT
    CHECKCOMPAT --> UNBLOCKCLIENT
    UNBLOCKCLIENT --> RELEASEENTRY
    RELEASEENTRY --> UPDATECOUNTERS
    UPDATECOUNTERS --> CLEANBSTATE
```

**来源：** [src/blocked.c475-522](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L475-L522) [src/blocked.c535-568](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L535-L568) [src/blocked.c581-616](https://github.com/redis/redis/blob/8ad54215/src/blocked.c#L581-L616) [src/t\_stream.c420-662](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L420-L662)

流操作与阻塞系统无缝集成：

1.  **信号生成**：
    -   `XADD` 操作在成功添加条目后调用 `signalKeyAsReady()`。
    -   `signalDeletedKeyAsReady()` 处理键删除场景。
    -   类型检查确保仅解除合适的客户端的阻塞。
2.  **客户端处理**：
    -   `handleClientsBlockedOnKeys()` 在 `beforeSleep()` 中运行，以实现高效的批量处理。
    -   通过按键的 FIFO 顺序处理客户端来维持公平性。
    -   使用 `in_handling_blocked_clients` 标志位防止递归解除阻塞。
3.  **状态清理**：
    -   `releaseBlockedEntry()` 从阻塞键映射中移除客户端。
    -   引用计数确保正确清理 `blocking_keys_unblock_on_nokey`。
    -   统计数据被更新以反映解除阻塞后的客户端状态变化。

这种集成系统使 Redis 流能够提供响应灵敏的、事件驱动的数据处理，同时在并发操作中保持一致性和性能。

## 流管理与维护

### 修剪与内存管理

```mermaid
flowchart TD
    TRIM["streamTrim() 主修剪函数"]
    STRATEGY["修剪策略：MAXLEN 或 MINID"]
    MAXLEN["TRIM_STRATEGY_MAXLEN 按最大长度修剪"]
    MINID["TRIM_STRATEGY_MINID 修剪 ID 小于特定值的条目"]
    APPROX["approx_trim 近似 vs 精确"]
    NODEREMOVE["移除整个节点 高效删除"]
    ENTRYMARK["将条目标记为已删除 STREAM_ITEM_FLAG_DELETED"]
    UPDATECOUNT["更新计数器：条目/删除计数"]
    KEEPREF["DELETE_STRATEGY_KEEPREF 保留 CG 引用"]
    DELREF["DELETE_STRATEGY_DELREF 移除 CG 引用"]
    ACKED["DELETE_STRATEGY_ACKED 仅删除已确认的条目"]
    EXACT["精确模式：= 修饰符 删除特定数量"]
    APPROXMODE["近似模式：~ 修饰符 删除整个节点"]
    LIMIT["LIMIT 选项 每次调用最大删除量"]

    TRIM --> STRATEGY
    STRATEGY --> MAXLEN
    STRATEGY --> MINID
    MAXLEN --> APPROX
    MINID --> APPROX
    APPROX --> NODEREMOVE
    APPROX --> ENTRYMARK
    ENTRYMARK --> UPDATECOUNT
    STRATEGY --> KEEPREF
    STRATEGY --> DELREF
    STRATEGY --> ACKED
    APPROX --> EXACT
    APPROX --> APPROXMODE
    EXACT --> LIMIT
```

**来源：** [src/t\_stream.c686-699](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L686-L699) [src/t\_stream.c724-914](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L724-L914) [src/t\_stream.c917-939](https://github.com/redis/redis/blob/8ad54215/src/t_stream.c#L917-L939)

流修剪通过 `streamTrim()` 函数实现，具有几个关键特性：

1.  **修剪策略**：
    -   `TRIM_STRATEGY_MAXLEN`：修剪到指定的最大条目数。
    -   `TRIM_STRATEGY_MINID`：移除 ID 小于指定 ID 的条目。
2.  **精度模式**：
    -   精确模式 (`=` 修饰符)：精确修剪到指定的数量。
    -   近似模式 (`~` 修饰符)：为了效率，仅移除完整的节点。
3.  **删除策略**：
    -   `DELETE_STRATEGY_KEEPREF`：保留消费者组引用（默认）。
    -   `DELETE_STRATEGY_DELREF`：移除消费者组引用。
    -   `DELETE_STRATEGY_ACKED`：仅删除已被所有组确认的条目。
4.  **性能控制**：
    -   `LIMIT` 选项：限制每次调用处理的条目数量。
    -   节点级优化：尽可能移除整个节点。
    -   条目标记：使用 `STREAM_ITEM_FLAG_DELETED` 将条目标记为已删除。

该实现在内存效率与性能之间取得了平衡，允许应用程序通过各种选项控制权衡。

### 迭代器与范围查询系统

```mermaid
flowchart TD
    ITERATOR["streamIterator 迭代器结构体"]
    START["streamIteratorStart() 开始迭代"]
    GETID["streamIteratorGetID() 获取 ID"]
    GETFIELD["streamIteratorGetField() 获取字段"]
    STOP["streamIteratorStop() 停止迭代"]
    MASTERID["master_id 主条目 ID"]
    MASTERFIELDS["master_fields_* 主条目字段"]
    ENTRYFLAGS["entry_flags 条目标志"]
    REVERSE["rev (正向或反向)"]
    SKIPTOMB["skip_tombstones 跳过墓碑"]
    XRANGE["XRANGE 命令"]
    XREVRANGE["XREVRANGE 命令"]
    REPLYRANGE["streamReplyWithRange()"]

    START --> GETID
    GETID --> GETFIELD
    GETFIELD --> GETID
    GETID --> STOP
    START --> MASTERID
    START --> REVERSE
    GETID --> ENTRYFLAGS
    XRANGE --> REPLYRANGE
    XREVRANGE --> REPLYRANGE
    REPLYRANGE --> ITERATOR
```

**来源：** [src/stream.h32-52](https://github.com/redis/redis/blob/8ad54215/src/stream.h#L32-L52) [src/stream.h119-124](https://github.com/redis/redis/blob/8ad54215/src/stream.h#L119-L124)

`streamIterator` 为正向或反向遍历流条目提供了统一接口，自动处理压缩和墓碑过滤。

该流系统使 Redis 能够既作为简单的消息队列，也作为具有消费者组语义、持久化消息递送以及对时间排序数据的高效范围查询的复杂事件流平台。
