# 10.3 重排序与元数据过滤 (Reranking and Metadata Filtering)

相关源文件：

- [api/db/services/dialog_service.py](https://github.com/infiniflow/ragflow/blob/80a16e71/api/db/services/dialog_service.py)
- [rag/nlp/search.py](https://github.com/infiniflow/ragflow/blob/80a16e71/rag/nlp/search.py)
- [rag/llm/rerank_model.py](https://github.com/infiniflow/ragflow/blob/80a16e71/rag/llm/rerank_model.py)
- [common/metadata_utils.py](https://github.com/infiniflow/ragflow/blob/80a16e71/common/metadata_utils.py)

本页面介绍了 RAGFlow 的重排序（Reranking）和元数据过滤（Metadata Filtering）机制。这些机制在混合搜索之后应用，用于进一步精炼检索结果。重排序使用专门的大模型对切片进行相关性排序，而元数据过滤则允许根据文档属性进行选择性检索。

---

## 重排序系统 (Reranking System)

### 概述
重排序是检索后的一个可选步骤，用于对混合搜索返回的切片进行重新排序。RAGFlow 支持两种重排序方式：
1.  **基于模型的重排序**：通过 `LLMBundle` 调用专门的重排序模型（如 Jina, BGE, Cohere）。
2.  **混合相似度重排序**：结合词法重叠和向量相似度进行打分，无需外部模型。

### 核心逻辑
重排序逻辑主要实现在 `Dealer.rerank()` 方法中。系统会结合搜索原始得分、重排序模型得分以及 PageRank 等特征信号，计算出最终的综合评分。

---

## 元数据过滤系统 (Metadata Filtering)

### 概述
元数据过滤允许基于解析时提取或手动添加的结构化属性（如作者、分类、日期等）进行切片的筛选。

### 过滤架构
1.  **提取元数据**：从数据库中获取指定知识库的所有文档元数据。
2.  **应用逻辑**：根据用户提供的 `logic`（and/or）和 `conditions`（条件列表）进行过滤。
3.  **约束检索**：将过滤得到的 `doc_ids` 作为限制条件传递给检索引擎，从而显著缩小搜索空间。

### 支持的操作符
- `is` (等于), `is_not` (不等于)
- `contains` (包含), `not_contains` (不包含)
- `is_any_of` (属于列表之一), `is_not_any_of` (不属于列表)
- `greater_equal`, `less_equal` (数值比较)

---

## 综合应用：重排序 + 元数据过滤

在完整的 RAG 流水线中，这两个功能协同工作：
1.  **首先应用元数据过滤**：在检索前约束搜索范围。
2.  **执行混合搜索**：在过滤后的文档中召回 Top-K 候选切片（通常为 1024 个）。
3.  **执行重排序**：对 Top-K 候选切片进行精细打分，选取 Top-N（如前 6 个）作为回答上下文。

---

## 性能考量 (Performance Considerations)

- **重排序延迟**：调用云端重排序模型通常会增加 200-500ms 的延迟，但能显著提升回答精度。
- **过滤效率**：简单的元数据过滤通常非常快（<50ms），且能通过排除无关文档来提高后续环节的效率。
- **Top-K 限制**：重排序仅应用于初步召回的 Top-K 候选集，而非全量数据，以平衡精度与响应速度。

---

## 总结 (Summary)

重排序与元数据过滤是 RAGFlow 提升检索质量的两大利器：
- **重排序**：通过深度学习模型解决了简单向量检索可能存在的语义偏差。
- **元数据过滤**：为非结构化检索引入了结构化约束，适配了复杂的企业级权限和数据组织场景。
- **协同效应**：二者结合实现了“先过滤、后召回、再精排”的高精度处理模式。
